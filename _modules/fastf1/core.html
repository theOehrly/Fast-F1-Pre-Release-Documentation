<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 6.1.2 and Furo 2022.12.07 -->
        <title>fastf1.core - Fast F1 2.3.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Fast F1 2.3.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Fast F1 2.3.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/theOehrly/Fast-F1">‚Üê Back to Github</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../examples/index.html">Getting Started</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples/basics.html">Getting started with the basics</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../examples_gallery/index.html">Examples Gallery</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/example_fastf1_signalrclient.html">Using the Fast-F1 signalr client?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/plot_speed_traces.html">Overlaying speed traces of two laps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/plot_gear_shifts_on_track.html">Gear shifts on track</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/plot_qualifying_results.html">Qualifying results overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/plot_who_can_still_win_wdc.html">Who can still win the drivers WDC?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examples_gallery/plot_speed_on_track.html">Speed visualization on track map</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../fastf1.html">General Functions - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html">Timing and Telemetry Data - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.core</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core.html#api-reference">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../events.html">Event Schedule - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.events</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">F1 API - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.api</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ergast.html">Ergast API Interface - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.ergast</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utils module - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.utils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plotting.html">Plotting - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.plotting</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livetiming.html">Live Timing Client - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.livetiming</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../legacy.html">Legacy Functionality - <code class="xref py py-mod docutils literal notranslate"><span class="pre">fastf1.legacy</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../time_explanation.html">Time, Date and Timing - Explanation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto_accurate_calculations.html">How to perform calculations accurately</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../known_bugs.html">Known bugs and caveats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../contributing/index.html">Contributing</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/devenv_setup.html">Setting up FastF1 for development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/testing.html">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/documenting_fastf1.html">Writing documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/coding_guide.html">Pull request guidelines</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for fastf1.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Timing and Telemetry Data - :mod:`fastf1.core`</span>
<span class="sd">==============================================</span>

<span class="sd">The Fast-F1 core is a collection of functions and data objects for accessing</span>
<span class="sd">and analyzing F1 timing and telemetry data.</span>

<span class="sd">Data Objects</span>
<span class="sd">------------</span>

<span class="sd">All data is provided through the following data objects:</span>

<span class="sd">    .. autosummary::</span>
<span class="sd">       :nosignatures:</span>

<span class="sd">       Weekend</span>
<span class="sd">       Session</span>
<span class="sd">       Laps</span>
<span class="sd">       Lap</span>
<span class="sd">       Telemetry</span>
<span class="sd">       SessionResults</span>
<span class="sd">       DriverResult</span>


<span class="sd">The :class:`Session` object is mainly used as an entry point for loading</span>
<span class="sd">timing data and telemetry data. The :class:`Session` can create a</span>
<span class="sd">:class:`Laps` object which contains all timing, track and session status</span>
<span class="sd">data for a whole session.</span>

<span class="sd">Usually you will be using :func:`get_session` to get a :class:`Session`</span>
<span class="sd">object.</span>

<span class="sd">The :class:`Laps` object holds detailed information about multiples laps.</span>

<span class="sd">The :class:`Lap` object holds the same information as :class:`Laps` but only</span>
<span class="sd">for one single lap. When selecting a single lap from a :class:`Laps` object,</span>
<span class="sd">an object of type :class:`Lap` will be returned.</span>

<span class="sd">Apart from only providing data, the :class:`Laps`, :class:`Lap` and</span>
<span class="sd">:class:`Telemetry` objects implement various methods for selecting and</span>
<span class="sd">analyzing specific parts of the data.</span>


<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">    get_session</span>
<span class="sd">    get_round</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">fastf1</span>
<span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">api</span><span class="p">,</span> <span class="n">ergast</span>
<span class="kn">from</span> <span class="nn">fastf1.utils</span> <span class="kn">import</span> <span class="n">recursive_dict_get</span><span class="p">,</span> <span class="n">to_timedelta</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;{&#39;</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{module: &lt;8}</span><span class="s2"> </span><span class="si">{levelname: &gt;10}</span><span class="s2"> </span><span class="se">\t</span><span class="si">{message}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">D_LOOKUP</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> \
    <span class="p">[[</span><span class="mi">44</span><span class="p">,</span> <span class="s1">&#39;HAM&#39;</span><span class="p">,</span> <span class="s1">&#39;Mercedes&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">77</span><span class="p">,</span> <span class="s1">&#39;BOT&#39;</span><span class="p">,</span> <span class="s1">&#39;Mercedes&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">55</span><span class="p">,</span> <span class="s1">&#39;SAI&#39;</span><span class="p">,</span> <span class="s1">&#39;Ferrari&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;LEC&#39;</span><span class="p">,</span> <span class="s1">&#39;Ferrari&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">33</span><span class="p">,</span> <span class="s1">&#39;VER&#39;</span><span class="p">,</span> <span class="s1">&#39;Red Bull&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;PER&#39;</span><span class="p">,</span> <span class="s1">&#39;Red Bull&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;RIC&#39;</span><span class="p">,</span> <span class="s1">&#39;McLaren&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;NOR&#39;</span><span class="p">,</span> <span class="s1">&#39;McLaren&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;VET&#39;</span><span class="p">,</span> <span class="s1">&#39;Aston Martin&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="s1">&#39;STR&#39;</span><span class="p">,</span> <span class="s1">&#39;Aston Martin&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="s1">&#39;ALO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alpine&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">31</span><span class="p">,</span> <span class="s1">&#39;OCO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alpine&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="s1">&#39;TSU&#39;</span><span class="p">,</span> <span class="s1">&#39;AlphaTauri&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;GAS&#39;</span><span class="p">,</span> <span class="s1">&#39;AlphaTauri&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">47</span><span class="p">,</span> <span class="s1">&#39;MSC&#39;</span><span class="p">,</span> <span class="s1">&#39;Haas F1 Team&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;MAZ&#39;</span><span class="p">,</span> <span class="s1">&#39;Haas F1 Team&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;RAI&#39;</span><span class="p">,</span> <span class="s1">&#39;Alfa Romeo&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">99</span><span class="p">,</span> <span class="s1">&#39;GIO&#39;</span><span class="p">,</span> <span class="s1">&#39;Alfa Romeo&#39;</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;LAT&#39;</span><span class="p">,</span> <span class="s1">&#39;Williams&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">63</span><span class="p">,</span> <span class="s1">&#39;RUS&#39;</span><span class="p">,</span> <span class="s1">&#39;Williams&#39;</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">get_session</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Session&quot;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. deprecated:: 2.2</span>
<span class="sd">        replaced by :func:`fastf1.get_session`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO remove</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`fastf1.core.get_session` has been deprecated and will be&quot;</span>
                  <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;Use `fastf1.get_session` instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">events</span>
    <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">get_session</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_round</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. deprecated:: 2.2</span>
<span class="sd">        will be removed without replacement;</span>
<span class="sd">        Use :func:`fastf1.get_event` instead to get an</span>
<span class="sd">        :class:`~fastf1.events.Event` object which provides</span>
<span class="sd">        information including the round number for the event.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO remove</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;_func:`fastf1.core.get_round` has been deprecated and will &quot;</span>
                  <span class="s2">&quot;be removed without replacement in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;Use :func:`fastf1.get_event` instead to get an &quot;</span>
                  <span class="s2">&quot;:class:`~fastf1.events.Event` object which provides &quot;</span>
                  <span class="s2">&quot;information including the round number for the event.&quot;</span><span class="p">,</span>
                  <span class="ne">FutureWarning</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">events</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">event</span><span class="o">.</span><span class="n">RoundNumber</span>


<div class="viewcode-block" id="Telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry">[docs]</a><span class="k">class</span> <span class="nc">Telemetry</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multi-channel time series telemetry data</span>

<span class="sd">    The object can contain multiple telemetry channels. Multiple telemetry</span>
<span class="sd">    objects with different channels can be merged on time. Each telemetry</span>
<span class="sd">    channel is one dataframe column. Partial telemetry (e.g. for one lap only)</span>
<span class="sd">    can be obtained through various methods for slicing the data. Additionally,</span>
<span class="sd">    methods for adding common computed data channels are available.</span>

<span class="sd">    The following telemetry channels existed in the original API data:</span>

<span class="sd">        - **Car data**:</span>
<span class="sd">            - `Speed` (float): Car speed [km/h]</span>
<span class="sd">            - `RPM` (int): Car RPM</span>
<span class="sd">            - `nGear` (int): Car gear number</span>
<span class="sd">            - `Throttle` (float): 0-100 Throttle pedal pressure [%]</span>
<span class="sd">            - `Brake` (bool): Brakes are applied or not.</span>
<span class="sd">            - `DRS` (int): DRS indicator (See :func:`fastf1.api.car_data`</span>
<span class="sd">              for more info)</span>

<span class="sd">        - **Position data**:</span>
<span class="sd">            - `X` (float): X position [1/10 m]</span>
<span class="sd">            - `Y` (float): Y position [1/10 m]</span>
<span class="sd">            - `Z` (float): Z position [1/10 m]</span>
<span class="sd">            - `Status` (string): Flag - OffTrack/OnTrack</span>

<span class="sd">        - **For both of the above**:</span>
<span class="sd">            - `Time` (timedelta): Time (0 is start of the data slice)</span>
<span class="sd">            - `SessionTime` (timedelta): Time elapsed since the start of the</span>
<span class="sd">              session</span>
<span class="sd">            - `Date` (datetime): The full date + time at which this sample</span>
<span class="sd">              was created</span>
<span class="sd">            - `Source` (str): Flag indicating how this sample was created:</span>

<span class="sd">                - &#39;car&#39;: sample from original api car data</span>
<span class="sd">                - &#39;pos&#39;: sample from original api position data</span>
<span class="sd">                - &#39;interpolated&#39;: this sample was artificially created; all</span>
<span class="sd">                  values are computed/interpolated</span>

<span class="sd">                Example:</span>
<span class="sd">                    A sample&#39;s source is indicated as &#39;car&#39;. It contains</span>
<span class="sd">                    values for speed, rpm and x, y, z coordinates.</span>
<span class="sd">                    Originally, this sample (with its timestamp) was received</span>
<span class="sd">                    when loading car data.</span>
<span class="sd">                    This means that the speed and rpm value are original</span>
<span class="sd">                    values as received from the api. The coordinates are</span>
<span class="sd">                    interpolated for this sample.</span>

<span class="sd">                    All methods of :class:`Telemetry` which resample or</span>
<span class="sd">                    interpolate data will preserve and adjust the source flag</span>
<span class="sd">                    correctly when modifying data.</span>

<span class="sd">        Through merging/slicing it is possible to obtain any combination of</span>
<span class="sd">        telemetry channels!</span>
<span class="sd">        The following additional computed data channels can be added:</span>

<span class="sd">            - Distance driven between two samples:</span>
<span class="sd">              :meth:`add_differential_distance`</span>
<span class="sd">            - Distance driven since the first sample:</span>
<span class="sd">              :meth:`add_distance`</span>
<span class="sd">            - Relative distance driven since the first sample:</span>
<span class="sd">              :meth:`add_relative_distance`</span>
<span class="sd">            - Distance to driver ahead and car number of said driver:</span>
<span class="sd">              :meth:`add_driver_ahead`</span>

<span class="sd">        .. note:: See the separate explanation concerning the various</span>
<span class="sd">          definitions of &#39;Time&#39; for more information on the three date and</span>
<span class="sd">          time related channels: :ref:`time-explanation`</span>

<span class="sd">    Slicing this class will return :class:`Telemetry` again for slices</span>
<span class="sd">    containing multiple rows. Single rows will be returned as</span>
<span class="sd">    :class:`pandas.Series`.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args (any): passed through to `pandas.DataFrame` superclass</span>
<span class="sd">        session (:class:`Session`): Instance of associated session object.</span>
<span class="sd">            Required for full functionality!</span>
<span class="sd">        driver (str): Driver number as string. Required for full functionality!</span>
<span class="sd">        **kwargs (any): passed through to `pandas.DataFrame` superclass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TELEMETRY_FREQUENCY</span> <span class="o">=</span> <span class="s1">&#39;original&#39;</span>
    <span class="sd">&quot;&quot;&quot;Defines the frequency used when resampling the telemetry data. Either</span>
<span class="sd">    the string ``&#39;original&#39;`` or an integer to specify a frequency in Hz.&quot;&quot;&quot;</span>

    <span class="n">_CHANNELS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Status&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Speed&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>  <span class="c1"># linear is often required as quadratic overshoots</span>
        <span class="s1">&#39;RPM&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>  <span class="c1"># on sudden changes like sudden pedal application)</span>
        <span class="s1">&#39;Throttle&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Brake&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DRS&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;nGear&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Source&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, custom handling</span>
        <span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, used as the index during resampling</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>  <span class="c1"># special case, Time/SessionTime recalculated from &#39;Date&#39;</span>
        <span class="s1">&#39;SessionTime&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;excluded&#39;</span><span class="p">},</span>
        <span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;RelativeDistance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DriverAhead&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;discrete&#39;</span><span class="p">},</span>
        <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="s1">&#39;linear&#39;</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="sd">&quot;&quot;&quot;Known telemetry channels which are supported by default&quot;&quot;&quot;</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">,</span> <span class="s1">&#39;driver&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">drop_unknown_channels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Session</span><span class="p">]</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">driver</span> <span class="o">=</span> <span class="n">driver</span>

        <span class="k">if</span> <span class="n">drop_unknown_channels</span><span class="p">:</span>
            <span class="n">unknown</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">unknown</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unknown</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The following unknown telemetry channels have &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;been dropped when creating a Telemetry object: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">unknown</span><span class="si">}</span><span class="s2"> (driver: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Telemetry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_class_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a nicer debugging experience; can view DataFrame through this property in various IDEs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Telemetry.join"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraps :mod:`pandas.DataFrame.join` and adds metadata propagation.</span>

<span class="sd">        When calling `self.join` metadata will be propagated from self to the joined dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.merge"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraps :mod:`pandas.DataFrame.merge` and adds metadata propagation.</span>

<span class="sd">        When calling `self.merge` metadata will be propagated from self to the merged dataframe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_mask"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_mask">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Slice self using a boolean array as a mask.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (array-like): Array of boolean values with the same length as self</span>
<span class="sd">            pad (int): Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side (str): Where to pad the data; possible options: &#39;both&#39;, &#39;before&#39;, &#39;after&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pad</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pad_side</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">):</span>
                <span class="n">i_left_pad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_left_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">pad_side</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">):</span>
                <span class="n">i_right_pad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span> <span class="o">+</span> <span class="n">pad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_right_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i_left_pad</span><span class="p">:</span> <span class="n">i_right_pad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">data_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data_slice</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_lap"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_lap">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_lap</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ref_laps</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Lap&quot;</span><span class="p">,</span> <span class="s2">&quot;Laps&quot;</span><span class="p">],</span>
            <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">pad_side</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span>
            <span class="n">interpolate_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice self to only include data from the provided lap or laps.</span>

<span class="sd">        .. note:: Self needs to contain a &#39;SessionTime&#39; column.</span>

<span class="sd">        .. note:: When slicing with an instance of :class:`Laps` as a reference, the data will be sliced by first and</span>
<span class="sd">            last lap. Missing laps in between will not be considered and data for these will still be included in</span>
<span class="sd">            the sliced result.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_laps: The lap/laps by which to slice self</span>
<span class="sd">            pad: Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side: Where to pad the data; possible options:</span>
<span class="sd">                &#39;both&#39;, &#39;before&#39;, &#39;after</span>
<span class="sd">            interpolate_edges: Add an interpolated sample at the beginning</span>
<span class="sd">                and end to exactly match the provided time window.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="n">Laps</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;DriverNumber&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Laps is missing &#39;DriverNumber&#39;. Cannot return telemetry for unknown driver.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot create telemetry for multiple drivers at once!&quot;</span><span class="p">)</span>

            <span class="n">end_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="p">(</span><span class="n">Lap</span><span class="p">,</span> <span class="n">Laps</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_laps</span><span class="p">,</span> <span class="n">Laps</span><span class="p">):</span>  <span class="c1"># one lap in Laps</span>
                <span class="n">ref_laps</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># needs to be handled as a single lap</span>
            <span class="k">if</span> <span class="s1">&#39;DriverNumber&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_laps</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Lap is missing &#39;DriverNumber&#39;. Cannot return telemetry for unknown driver.&quot;</span><span class="p">)</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">ref_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Attribute &#39;ref_laps&#39; needs to be an instance of `Lap` or `Laps`&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_by_time</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad_side</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.slice_by_time"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.slice_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">slice_by_time</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_time</span><span class="p">,</span>
            <span class="n">end_time</span><span class="p">,</span>
            <span class="n">pad</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">pad_side</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span>
            <span class="n">interpolate_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Slice self to only include data in a specific time frame.</span>

<span class="sd">        .. note:: Self needs to contain a &#39;SessionTime&#39; column. Slicing by time use the &#39;SessionTime&#39; as its reference.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_time (Timedelta): Start of the section</span>
<span class="sd">            end_time (Timedelta): End of the section</span>
<span class="sd">            pad: Number of samples used for padding the sliced data</span>
<span class="sd">            pad_side: Where to pad the data; possible options:</span>
<span class="sd">                &#39;both&#39;, &#39;before&#39;, &#39;after</span>
<span class="sd">            interpolate_edges: Add an interpolated sample at the beginning</span>
<span class="sd">                and end to exactly match the provided time window.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interpolate_edges</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">({</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">),</span>
                               <span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span><span class="p">,</span> <span class="n">end_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span><span class="p">)},</span>
                              <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># TODO no copy?</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sel</span><span class="p">):</span>
            <span class="n">data_slice</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">slice_by_mask</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">pad_side</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;Time&#39;</span> <span class="ow">in</span> <span class="n">data_slice</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># shift time to 0 so laps can overlap</span>
                <span class="n">data_slice</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_slice</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_time</span>

            <span class="k">return</span> <span class="n">data_slice</span>
        <span class="k">return</span> <span class="n">Telemetry</span><span class="p">()</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.merge_channels"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.merge_channels">[docs]</a>    <span class="k">def</span> <span class="nf">merge_channels</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Telemetry&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
            <span class="n">frequency</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge telemetry objects containing different telemetry channels.</span>

<span class="sd">        The two objects don&#39;t need to have a common time base. The data will be merged, optionally resampled and</span>
<span class="sd">        missing values will be interpolated.</span>

<span class="sd">        :attr:`Telemetry.TELEMETRY_FREQUENCY` determines if and how the data is resampled. This can be overridden using</span>
<span class="sd">        the `frequency` keyword fo this method.</span>

<span class="sd">        Merging and resampling:</span>

<span class="sd">            If the frequency is &#39;original&#39;, data will not be resampled. The two objects will be merged and all</span>
<span class="sd">            timestamps of both objects are kept. Values will be interpolated so that all telemetry channels contain</span>
<span class="sd">            valid data for all timestamps. This is the default and recommended option.</span>

<span class="sd">            If the frequency is specified as an integer in Hz the data will be merged as before. After that, the merged</span>
<span class="sd">            time base will be resampled from the first value on at the specified frequency. Afterwards, the data will</span>
<span class="sd">            be interpolated to fit the new time base. This means that usually most if not all values of the data will</span>
<span class="sd">            be interpolated values. This is detrimental for overall accuracy.</span>

<span class="sd">        Interpolation:</span>

<span class="sd">            Missing values after merging will be interpolated for all known telemetry channels using</span>
<span class="sd">            :meth:`fill_missing`. Different interpolation methods are used depending on what kind of data the channel</span>
<span class="sd">            contains. For example, forward fill is used to interpolated &#39;nGear&#39; while linear interpolation is used</span>
<span class="sd">            for &#39;RPM&#39; interpolation.</span>

<span class="sd">        .. note :: Unknown telemetry channels will be merged but missing values will not be interpolated. This can</span>
<span class="sd">            either be done manually or a custom telemetry channel can be added using :meth:`register_new_channel`.</span>

<span class="sd">        .. note :: Do not resample data multiple times. Always resample based on the original data</span>
<span class="sd">            to preserve accuracy</span>

<span class="sd">        Args:</span>
<span class="sd">            other: Object to be merged with self</span>
<span class="sd">            frequency: Optional frequency to overwrite global preset.</span>
<span class="sd">                (Either string &#39;original&#39; or integer for a frequency in Hz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># merge the data and interpolate missing; &#39;Date&#39; needs to be the index</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">)</span>

        <span class="c1"># save dtypes before merging so they can be restored after merging</span>
        <span class="c1"># necessary for example because merging produces NaN values which would cause an int column to become float</span>
        <span class="c1"># but it can be converted back to int after interpolating missing values</span>
        <span class="n">dtype_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtype_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">dtype_map</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Exclude columns existing on both dataframes from one dataframe before merging (cannot merge with duplicates)</span>
        <span class="n">on_both_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">on_both_columns</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                             <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># now use the previously excluded columns to update the missing values in the merged dataframe</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">on_both_columns</span><span class="p">:</span>
            <span class="n">merged</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

        <span class="k">if</span> <span class="s1">&#39;Driver&#39;</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge multiple drivers&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">frequency</span><span class="p">:</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">TELEMETRY_FREQUENCY</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_first_non_zero_time_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No valid &#39;Time&#39; data. Cannot resample!&quot;</span><span class="p">)</span>

        <span class="n">ref_date</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># data needs to be resampled/interpolated differently, depending on what kind of data it is</span>
        <span class="c1"># how to handle which column is defined in self._CHANNELS</span>

        <span class="k">if</span> <span class="n">frequency</span> <span class="o">==</span> <span class="s1">&#39;original&#39;</span><span class="p">:</span>
            <span class="c1"># no resampling but still interpolation due to merging</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">fill_missing</span><span class="p">()</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">})</span>  <span class="c1"># make &#39;Date&#39; a column again</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">frq</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">1</span> <span class="o">/</span> <span class="n">frequency</span><span class="si">}</span><span class="s1">S&#39;</span>

            <span class="n">resampled_columns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">sig_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;missing&#39;</span><span class="p">]</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> \
                        <span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;discrete&#39;</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
                    <span class="c1"># first ffill is a method of the resampler object and will ONLY ffill values created during</span>
                    <span class="c1"># resampling but not already existing NaN values. NaN values already existed because of merging,</span>
                    <span class="c1"># therefore call ffill a second time as a method of the returned series to fill these too</span>
                    <span class="c1"># only use bfill after ffill to fix first row</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">resampled_columns</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>

            <span class="n">res_source</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">frq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ref_date</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>
            <span class="n">resampled_columns</span><span class="p">[</span><span class="s1">&#39;Source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_source</span>

            <span class="c1"># join resampled columns and make &#39;Date&#39; a column again</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">resampled_columns</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span> \
                <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">})</span>

            <span class="c1"># recalculate the time columns</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># restore data types from before merging</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">dtype_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_map</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to preserve data type for column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; while merging telemetry.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged</span></div>

<div class="viewcode-block" id="Telemetry.resample_channels"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.resample_channels">[docs]</a>    <span class="k">def</span> <span class="nf">resample_channels</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">rule</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">new_date_ref</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample telemetry data.</span>

<span class="sd">        Convenience method for frequency conversion and resampling. Up and down sampling of data is supported.</span>
<span class="sd">        &#39;Date&#39; and &#39;SessionTime&#39; need to exist in the data. &#39;Date&#39; is used as the main time reference.</span>

<span class="sd">        There are two ways to use this method:</span>

<span class="sd">            - Usage like :meth:`pandas.DataFrame.resample`: In this case you need to specify the &#39;rule&#39; for resampling</span>
<span class="sd">              and any additional keywords will be passed on to :meth:`pandas.Series.resample` to create a new time</span>
<span class="sd">              reference. See the pandas method to see which options are available.</span>

<span class="sd">            - using the &#39;new_date_ref&#39; keyword a :class:`pandas.Series` containing new values for date</span>
<span class="sd">              (dtype :class:`pandas.Timestamp`) can be provided. The existing data will be resampled onto this new</span>
<span class="sd">              time reference.</span>

<span class="sd">        Args:</span>
<span class="sd">            rule: Resampling rule for :meth:`pandas.Series.resample`</span>
<span class="sd">            new_date_ref: New custom Series of reference dates</span>
<span class="sd">            **kwargs: Only in combination with &#39;rule&#39;; additional parameters</span>
<span class="sd">                for :meth:`pandas.Series.resample`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You can only specify one of &#39;rule&#39; or &#39;new_index&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rule</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify either &#39;rule&#39; or &#39;new_index&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_date_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">()</span>
            <span class="n">new_date_ref</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">new_tel</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">new_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_date_ref</span>

        <span class="n">combined_tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span>
            <span class="n">Telemetry</span><span class="p">({</span><span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="n">new_date_ref</span><span class="p">})</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">combined_tel</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">new_date_ref</span><span class="p">)</span>
        <span class="n">new_tel</span> <span class="o">=</span> <span class="n">combined_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">new_tel</span></div>

<div class="viewcode-block" id="Telemetry.fill_missing"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.fill_missing">[docs]</a>    <span class="k">def</span> <span class="nf">fill_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate missing values in self.</span>

<span class="sd">        Only known telemetry channels will be interpolated. Unknown channels are skipped and returned unmodified.</span>
<span class="sd">        Interpolation will be done according to the default mapping and according to options specified for</span>
<span class="sd">        registered custom channels. For example:</span>
<span class="sd">        | Linear interpolation will be used for continuous values (Speed, RPM)</span>
<span class="sd">        | Forward-fill will be used for discrete values (Gear, DRS, ...)</span>

<span class="sd">        See :meth:`register_new_channel` for adding custom channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sig_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>  <span class="c1"># yes, this is necessary to prevent pandas from crashing</span>
                <span class="k">if</span> <span class="n">ret</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Interpolation not possible for telemetry &quot;</span>
                                  <span class="s2">&quot;channel because dtype is &#39;object&#39;&quot;</span><span class="p">)</span>
                <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="s1">&#39;missing&#39;</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> \
                    <span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">sig_type</span> <span class="o">==</span> <span class="s1">&#39;discrete&#39;</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">()</span>
                <span class="c1"># first ffill is a method of the resampler object and will ONLY ffill values created during</span>
                <span class="c1"># resampling but not already existing NaN values. NaN values already existed because of merging,</span>
                <span class="c1"># therefore call ffill a second time as a method of the returned series to fill these too</span>
                <span class="c1"># only use bfill after ffill to fix first row</span>

        <span class="k">if</span> <span class="s1">&#39;Source&#39;</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Source&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;interpolation&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;Date&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">t0_date</span>  <span class="c1"># assume index is Date</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Telemetry.register_new_channel"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.register_new_channel">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register_new_channel</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">signal_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">interpolation_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a custom telemetry channel.</span>

<span class="sd">        Registered telemetry channels are automatically interpolated when merging or resampling data.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: Telemetry channel/column name</span>
<span class="sd">            signal_type: One of three possible signal types:</span>
<span class="sd">                - &#39;continuous&#39;: Speed, RPM, Distance, ...</span>
<span class="sd">                - &#39;discrete&#39;: DRS, nGear, status values, ...</span>
<span class="sd">                - &#39;excluded&#39;: Data channel will be ignored during resampling</span>
<span class="sd">            interpolation_method: The interpolation method</span>
<span class="sd">                which should be used. Can only be specified and is required</span>
<span class="sd">                in combination with ``signal_type=&#39;continuous&#39;``. See</span>
<span class="sd">                :meth:`pandas.Series.interpolate` for possible interpolation</span>
<span class="sd">                methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">signal_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;discrete&#39;</span><span class="p">,</span> <span class="s1">&#39;continuous&#39;</span><span class="p">,</span> <span class="s1">&#39;excluded&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown signal type </span><span class="si">{</span><span class="n">signal_type</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signal_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span> <span class="ow">and</span> <span class="n">interpolation_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;signal_type=&#39;continuous&#39; requires interpolation_method to be specified.&quot;</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_CHANNELS</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">signal_type</span><span class="p">,</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span> <span class="n">interpolation_method</span><span class="p">}</span></div>

<div class="viewcode-block" id="Telemetry.get_first_non_zero_time_index"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.get_first_non_zero_time_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_first_non_zero_time_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first index at which the &#39;Time&#39; value is not zero or NA/NaT&quot;&quot;&quot;</span>
        <span class="c1"># find first row where time is not zero; usually this is the first row but sometimes.....</span>
        <span class="n">i_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">i_arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Telemetry.add_differential_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_differential_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_differential_distance</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drop_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;DifferentialDistance&#39; to self.</span>

<span class="sd">        This column contains the distance driven between subsequent samples.</span>

<span class="sd">        Calls :meth:`calculate_differential_distance` and joins the result</span>
<span class="sd">        with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing: Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            self joined with new column or self if column exists</span>
<span class="sd">            and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;DifferentialDistance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">drop_existing</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">new_dif_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_differential_distance</span><span class="p">()}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;DifferentialDistance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;DifferentialDistance&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_dif_dist</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_dif_dist</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;Distance&#39; to self.</span>

<span class="sd">        This column contains the distance driven since the first sample of self in meters.</span>

<span class="sd">        The data is produced by integrating the differential distance between subsequent laps.</span>
<span class="sd">        You should not apply this function to telemetry of many laps simultaneously to reduce integration error.</span>
<span class="sd">        Instead apply it only to single laps or few laps at a time!</span>

<span class="sd">        Calls :meth:`integrate_distance` and joins the result with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing: Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            self joined with new column or self if column exists</span>
<span class="sd">            and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">drop_existing</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">new_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate_distance</span><span class="p">()})</span>
        <span class="k">if</span> <span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;Distance&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_dist</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_dist</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_relative_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_relative_distance">[docs]</a>    <span class="k">def</span> <span class="nf">add_relative_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;RelativeDistance&#39; to self.</span>

<span class="sd">        This column contains the distance driven since the first sample as</span>
<span class="sd">        a floating point number where ``0.0`` is the first sample of self</span>
<span class="sd">        and ``1.0`` is the last sample.</span>

<span class="sd">        This is calculated the same way as &#39;Distance&#39; (see: :meth:`add_distance`). The same warnings apply.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing: Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            self joined with new column or self if column exists</span>
<span class="sd">            and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;RelativeDistance&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;RelativeDistance&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="s1">&#39;Distance&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">rel_dist</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">integrate_distance</span><span class="p">()</span>
            <span class="n">rel_dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">dist</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;RelativeDistance&#39;</span><span class="p">:</span> <span class="n">rel_dist</span><span class="p">}),</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.add_driver_ahead"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.add_driver_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">add_driver_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">drop_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add column &#39;DriverAhead&#39; and &#39;DistanceToDriverAhead&#39; to self.</span>

<span class="sd">        DriverAhead: Driver number of the driver ahead as string</span>
<span class="sd">        DistanceToDriverAhead: Distance to next car ahead in meters</span>

<span class="sd">        .. note:: Cars in the pit lane are currently not excluded from the data. They will show up when overtaken on</span>
<span class="sd">            pit straight even if they&#39;re not technically in front of the car. A fix for this is TBD with other</span>
<span class="sd">            improvements.</span>

<span class="sd">        This should only be applied to data of single laps or few laps at a time to reduce integration error.</span>
<span class="sd">        For longer time spans it should be applied per lap and the laps</span>
<span class="sd">        should be merged afterwards.</span>
<span class="sd">        If you absolutely need to apply it to a whole session, use the legacy implementation. Note that data of</span>
<span class="sd">        the legacy implementation will be considerably less smooth. (see :mod:`fastf1.legacy`)</span>

<span class="sd">        Calls :meth:`calculate_driver_ahead` and joins the result with self.</span>

<span class="sd">        Args:</span>
<span class="sd">            drop_existing: Drop and recalculate column if it already exists</span>
<span class="sd">        Returns:</span>
<span class="sd">            self joined with new column or self if column exists</span>
<span class="sd">            and `drop_existing` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;DriverAhead&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_existing</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">drv_ahead</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">ref_tel</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_driver_ahead</span><span class="p">(</span><span class="n">return_reference</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># calculate driver ahead works with the unmodified source telemetry,</span>
        <span class="c1"># therefore it may be necessary to resample the result if self uses</span>
        <span class="c1"># a different timebase</span>
        <span class="c1"># create a Telemetry object where the calculation results are merged</span>
        <span class="c1"># with Date, Time and SessionTime. This is necessary so that the data</span>
        <span class="c1"># can be resampled from the reference timebase to the timebase of self</span>
        <span class="n">dtd</span> <span class="o">=</span> <span class="n">ref_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;SessionTime&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">:</span> <span class="n">drv_ahead</span><span class="p">,</span>
                          <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">},</span>
                         <span class="n">index</span><span class="o">=</span><span class="n">ref_tel</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">dtd</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                           <span class="o">!=</span> <span class="n">dtd</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))):</span>
            <span class="n">dtd</span> <span class="o">=</span> <span class="n">dtd</span><span class="o">.</span><span class="n">resample_channels</span><span class="p">(</span><span class="n">new_date_ref</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;SessionTime&quot;</span><span class="p">])</span>

        <span class="c1"># indices need to match as .join works index-on-index</span>
        <span class="n">dtd</span><span class="p">[</span><span class="s1">&#39;_SelfIndex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">index</span>
        <span class="n">dtd</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;_SelfIndex&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dtd</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">,</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">)],</span>
                      <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Telemetry.calculate_differential_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.calculate_differential_distance">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_differential_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the distance between subsequent samples of self.</span>

<span class="sd">        Distance is in meters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Speed&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">)]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Telemetry does not contain required channels &#39;Time&#39; and &#39;Speed&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">()</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Speed&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3.6</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">return</span> <span class="n">ds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span></div>

<div class="viewcode-block" id="Telemetry.integrate_distance"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.integrate_distance">[docs]</a>    <span class="k">def</span> <span class="nf">integrate_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the distance driven since the first sample of self.</span>

<span class="sd">        Distance is in meters. The data is produce by integration. Integration error will stack up when used for</span>
<span class="sd">        long slices of data. This should therefore only be used for data of single laps or few laps at a time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`pd.Series`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_differential_distance</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">()</span></div>

<div class="viewcode-block" id="Telemetry.calculate_driver_ahead"><a class="viewcode-back" href="../../core.html#fastf1.Telemetry.calculate_driver_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_driver_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_reference</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate driver ahead and distance to driver ahead.</span>

<span class="sd">        Driver ahead: Driver number of the driver ahead as string</span>
<span class="sd">        Distance to driver ahead: Distance to the car ahead in meters</span>

<span class="sd">        .. note:: This gives a smoother/cleaner result than the legacy implementation but WILL introduce</span>
<span class="sd">            integration error when used over long distances (more than one or two laps may sometimes be considered</span>
<span class="sd">            a long distance). If in doubt, do sanity checks (against the legacy version or in another way).</span>

<span class="sd">        Args:</span>
<span class="sd">            return_reference: Additionally return the reference</span>
<span class="sd">                telemetry data slice that is used to calculate the new data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            driver ahead (numpy.array), distance to driver ahead (numpy.array),</span>
<span class="sd">            [reference telemetry (optional, :class:`Telemetry`)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">t_end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">combined_distance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Assume the following lap profile as a catch all for all drivers</span>
        <span class="c1">#</span>
        <span class="c1"># |------ Lap before ------|------ n Laps between ------|------ Lap after ------|</span>
        <span class="c1">#        ^                                                   ^</span>
        <span class="c1">#        t_start                                             t_end</span>
        <span class="c1"># Integration of the distance needs to start at the finish line so that there exists a common zero point</span>
        <span class="c1"># Therefore find the &quot;lap before&quot; which is the lap during which the telemetry slice starts and the &quot;lap after&quot;</span>
        <span class="c1"># where the telemetry slice ends</span>
        <span class="c1"># Integrate distance over all relevant laps and slice by t_start and t_end after to get the interesting</span>
        <span class="c1"># part only</span>
        <span class="n">own_laps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span>
        <span class="n">first_lap_number</span> <span class="o">=</span> <span class="p">(</span><span class="n">own_laps</span><span class="p">[</span><span class="n">own_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t_start</span><span class="p">])[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">own_ref_tel</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># find correct first relevant lap; very important for correct zero point in distance</span>
            <span class="n">drv_laps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">drv_laps</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>  <span class="c1"># Only include drivers who participated in this session</span>
                <span class="k">continue</span>
            <span class="n">drv_laps_before</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t_start</span><span class="p">)]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">drv_laps_before</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">lap_n_before</span> <span class="o">=</span> <span class="n">drv_laps_before</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">lap_n_before</span> <span class="o">&lt;</span> <span class="n">first_lap_number</span><span class="p">:</span>
                    <span class="c1"># driver is behind on track an therefore will cross the finish line AFTER self</span>
                    <span class="c1"># therefore above check for LapStartTime &lt;= t_start is wrong</span>
                    <span class="c1"># the first relevant lap is the first lap with LapStartTime &gt; t_start which is lap_n_before += 1</span>
                    <span class="n">lap_n_before</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lap_n_before</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">])</span>

            <span class="c1"># find last relevant lap so as to no do too much unnecessary calculation later</span>
            <span class="n">drv_laps_after</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t_end</span><span class="p">]</span>
            <span class="n">lap_n_after</span> <span class="o">=</span> <span class="n">drv_laps_after</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> \
                <span class="k">if</span> <span class="ow">not</span> <span class="n">drv_laps_after</span><span class="o">.</span><span class="n">empty</span> \
                <span class="k">else</span> <span class="nb">max</span><span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">])</span>

            <span class="c1"># pad_before/_after is used to extend the range of relevant laps</span>
            <span class="c1"># by up to one lap in each direction if the previously determined</span>
            <span class="c1"># relevant laps at the beginning or end are missing their</span>
            <span class="c1"># LapStartTime or Time respectively</span>
            <span class="n">pad_before</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pad_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">relevant_laps</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">relevant_laps</span> <span class="o">=</span> <span class="n">drv_laps</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">lap_n_before</span> <span class="o">-</span> <span class="n">pad_before</span><span class="p">))</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">drv_laps</span><span class="p">[</span><span class="s1">&#39;LapNumber&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lap_n_after</span> <span class="o">+</span> <span class="n">pad_after</span><span class="p">)</span>
                        <span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">pad_before</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pad_after</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Car number </span><span class="si">{</span><span class="n">drv</span><span class="si">}</span><span class="s2"> cannot be located &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;on track while calculating the distance&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;between cars.&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">relevant_laps</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># a relevant timestamp is NaT; pad accordingly and try again</span>
                <span class="k">if</span> <span class="n">relevant_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">:</span>
                    <span class="n">pad_before</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">relevant_laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">:</span>
                    <span class="n">pad_after</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">relevant_laps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">relevant_laps</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># first slice by lap and calculate distance, so that distance is zero at finish line</span>
            <span class="n">drv_tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span> \
                <span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="n">relevant_laps</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span>

            <span class="c1"># now slice again by time to only get the relevant time frame</span>
            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">slice_by_time</span><span class="p">(</span><span class="n">t_start</span><span class="p">,</span> <span class="n">t_end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">drv</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">:</span>
                <span class="n">own_ref_tel</span> <span class="o">=</span> <span class="n">drv_tel</span>

            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">,</span> <span class="s1">&#39;Distance&#39;</span><span class="p">)]</span> \
                <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Distance&#39;</span><span class="p">:</span> <span class="n">drv</span><span class="p">})</span>

            <span class="n">drv_tel</span> <span class="o">=</span> <span class="n">drv_tel</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">)</span>
            <span class="n">combined_distance</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">drv_tel</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">)</span>

        <span class="c1"># create driver map for array</span>
        <span class="n">drv_map</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">own_dst</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">other_dst</span> <span class="o">=</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">combined_distance</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">driver</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="c1"># replace distance with nan if it does not change</span>
        <span class="c1"># prepend first row before diff so that array size stays the same; but missing first sample because of that</span>
        <span class="n">other_dst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">other_dst</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">other_dst</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># resize own_dst to match shape of other_dst for easy subtraction</span>
        <span class="n">own_dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">own_dst</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">other_dst</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">delta_dst</span> <span class="o">=</span> <span class="n">other_dst</span> <span class="o">-</span> <span class="n">own_dst</span>
        <span class="n">delta_dst</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">delta_dst</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># substitute nan with inf, else nan is returned as min</span>
        <span class="n">delta_dst</span><span class="p">[</span><span class="n">delta_dst</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>  <span class="c1"># remove cars behind so that neg numbers are not returned as min</span>

        <span class="n">index_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">delta_dst</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">drv_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">drv_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_ahead</span><span class="p">])</span>
        <span class="n">drv_ahead</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delta_dst</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># remove driver from all inf rows</span>

        <span class="n">dist_to_drv_ahead</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta_dst</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">index_ahead</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_ahead</span><span class="p">))])</span>
        <span class="n">dist_to_drv_ahead</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">delta_dst</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># remove value from all inf rows</span>

        <span class="k">if</span> <span class="n">return_reference</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">drv_ahead</span><span class="p">,</span> <span class="n">dist_to_drv_ahead</span><span class="p">,</span> <span class="n">own_ref_tel</span>

        <span class="k">return</span> <span class="n">drv_ahead</span><span class="p">,</span> <span class="n">dist_to_drv_ahead</span></div></div>


<div class="viewcode-block" id="Weekend"><a class="viewcode-back" href="../../core.html#fastf1.Weekend">[docs]</a><span class="k">class</span> <span class="nc">Weekend</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. deprecated:: 2.2</span>
<span class="sd">        Use :class:`fastf1.events.Event` instead</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`fastf1.core.Weekend` has been deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `fastf1.events.Event` instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">fastf1</span> <span class="kn">import</span> <span class="n">events</span>
        <span class="k">return</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span></div>


<div class="viewcode-block" id="Session"><a class="viewcode-back" href="../../core.html#fastf1.Session">[docs]</a><span class="k">class</span> <span class="nc">Session</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing session specific data.</span>

<span class="sd">    The session class will usually be your starting point. This object will</span>
<span class="sd">    have various information about the session.</span>

<span class="sd">    .. note:: Most of the data is only available after calling</span>
<span class="sd">        :func:`Session.load`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">session_name</span><span class="p">,</span> <span class="n">f1_api_support</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># TODO: load drivers immediately</span>
        <span class="c1"># TODO: load driver list for older seasons through ergast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>
        <span class="sd">&quot;&quot;&quot;:class:`~fastf1.events.Event`: Reference to the associated event</span>
<span class="sd">        object.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">session_name</span>
        <span class="sd">&quot;&quot;&quot;str: Name of this session, for example &#39;Qualifying&#39;, &#39;Race&#39;, &#39;FP1&#39;, ...&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f1_api_support</span> <span class="o">=</span> <span class="n">f1_api_support</span>
        <span class="sd">&quot;&quot;&quot;bool: The official F1 API supports this event and lap timing data and</span>
<span class="sd">        telemetry data are available.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get_session_date</span><span class="p">(</span><span class="n">session_name</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;pandas.Datetime: Date at which this session took place.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api_path</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">make_path</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;EventName&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;EventDate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;str: API base path for this session&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_session_status</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_race_control_messages</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_track_status</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_total_laps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="p">:</span> <span class="n">Laps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_t0_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_start_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_car_data</span><span class="p">:</span> <span class="nb">dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">:</span> <span class="nb">dict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_weather_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">:</span> <span class="n">SessionResults</span>

    <span class="k">def</span> <span class="nf">_get_property_warn_not_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataNotLoadedError</span><span class="p">(</span><span class="s2">&quot;The data you are trying to access has not &quot;</span>
                                     <span class="s2">&quot;been loaded yet. See `Session.load`&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weekend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deprecated: use :attr:`Session.event` instead&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The property `Session.weekend` has been renamed to &quot;</span>
                      <span class="s2">&quot;`Session.event`.</span><span class="se">\n</span><span class="s2"> The old property will be removed in&quot;</span>
                      <span class="s2">&quot;a future version.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">drivers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`list`: List of all drivers that took part in this</span>
<span class="sd">        session; contains driver numbers as string.</span>

<span class="sd">        Data is available after calling `Session.load`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">results</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SessionResults&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:class:`SessionResults`: Session result with driver information.</span>

<span class="sd">        Data is available after calling `Session.load`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_results&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">laps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:class:`Laps`: All laps from all drivers driven in this session.</span>

<span class="sd">        Data is available after calling `Session.load` with ``laps=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_laps&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_laps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:class:`int`: Originally scheduled number of laps for race-like</span>
<span class="sd">        sessions such as Race and Sprint. It takes None as a default value</span>
<span class="sd">        for other types of sessions or if data is unavailable</span>

<span class="sd">        Data is available after calling `Session.load` with ``laps=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_total_laps&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weather_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dataframe containing weather data for this session as received</span>
<span class="sd">        from the api. See :func:`fastf1.api.weather_data` for available data</span>
<span class="sd">        channels. Each data channel is one row of the dataframe.</span>

<span class="sd">        Data is available after calling `Session.load` with ``weather=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_weather_data&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">car_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of car telemetry (Speed, RPM, etc.) as received from</span>
<span class="sd">        the api by car number (where car number is a string and the telemetry</span>
<span class="sd">        is an instance of :class:`Telemetry`)</span>

<span class="sd">        Data is available after calling `Session.load` with ``telemetry=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_car_data&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Telemetry&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary of car position data as received from the api by car</span>
<span class="sd">        number (where car number is a string and the telemetry</span>
<span class="sd">        is an instance of :class:`Telemetry`)</span>

<span class="sd">        Data is available after calling `Session.load` with ``telemetry=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_pos_data&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">session_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`pandas.Dataframe`: Session status data as returned by</span>
<span class="sd">        :func:`fastf1.api.session_status_data`</span>

<span class="sd">        Data is available after calling `Session.load` with ``laps=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_session_status&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">track_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`pandas.Dataframe`: Track status data as returned by</span>
<span class="sd">        :func:`fastf1.api.track_status_data`</span>

<span class="sd">        Data is available after calling `Session.load` with ``laps=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_track_status&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">race_control_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`pandas.Dataframe`: Race Control messages as returned by</span>
<span class="sd">        :func:`fastf1.api.race_control_messages`</span>

<span class="sd">        Data is available after calling `Session.load` with ``messages=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_race_control_messages&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">session_start_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:class:`pandas.Timedelta`: Session time at which the session was</span>
<span class="sd">        started according to the session status data. This is not the</span>
<span class="sd">        time at which the session is scheduled to be started!</span>

<span class="sd">        Data is available after calling `Session.load` with ``laps=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_session_start_time&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t0_date</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`pandas.Datetime`: Date timestamp which marks the beginning</span>
<span class="sd">        of the data stream (the moment at which the session time is zero).</span>

<span class="sd">        Data is available after calling `Session.load` with ``telemetry=True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_property_warn_not_loaded</span><span class="p">(</span><span class="s1">&#39;_t0_date&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Session.load"><a class="viewcode-back" href="../../core.html#fastf1.Session.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">laps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">telemetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weather</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">messages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load session data from the supported APIs.</span>

<span class="sd">        This method allows to flexibly load some or all data that FastF1 can</span>
<span class="sd">        give you access to. Without specifying any further options, all data</span>
<span class="sd">        is loaded by default.</span>

<span class="sd">        Downloading and parsing of the data takes a considerable amount of</span>
<span class="sd">        time. Therefore, it is highly recommended to enable caching so that</span>
<span class="sd">        most of the data processing needs to be done only once.</span>

<span class="sd">        .. note:: **Lap data: drivers crashing and retiring**</span>

<span class="sd">            *During a session:*</span>
<span class="sd">            An additional last lap is added for a driver if the last timed</span>
<span class="sd">            lap of a driver is not an inlap and the session is aborted next.</span>
<span class="sd">            The `Time` for when this lap was &quot;set&quot; will be set to the time at</span>
<span class="sd">            which the session was aborted.</span>

<span class="sd">            *First lap in a race:*</span>
<span class="sd">            A single lap with minimal information will be added in race</span>
<span class="sd">            sessions if a driver does not complete at least one timed lap.</span>
<span class="sd">            The `LapStartTime` for this lap will be set to the start time</span>
<span class="sd">            of the session as with all other laps in a race. The `Time` at</span>
<span class="sd">            which this lap was &quot;set&quot; will be set to the time at which the</span>
<span class="sd">            first driver completes their first lap.</span>


<span class="sd">        .. note:: Absolute time is not super accurate. The moment a lap</span>
<span class="sd">            is logged is not always the same and there will be some</span>
<span class="sd">            jitter. At the moment lap time reference is synchronised</span>
<span class="sd">            on the sector time triggered with lowest latency.</span>
<span class="sd">            Expect an error of around ¬±10m when overlapping telemetry</span>
<span class="sd">            data of different laps.</span>

<span class="sd">        Args:</span>
<span class="sd">            laps (bool): Load laps and session status data.</span>
<span class="sd">            telemetry (bool): Load telemetry data.</span>
<span class="sd">            weather (bool): Load weather data.</span>
<span class="sd">            messages (bool): Load race control messages for the session</span>
<span class="sd">            livedata (:class:`fastf1.livetiming.data.LiveTimingData`, optional):</span>
<span class="sd">                instead of requesting the data from the api, locally saved</span>
<span class="sd">                livetiming data can be used as a data source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading data for &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;EventName&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot; [v</span><span class="si">{</span><span class="n">fastf1</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_load_drivers_results</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f1_api_support</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">laps</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_laps_data</span><span class="p">(</span><span class="n">livedata</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load lap data!&quot;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lap data failure traceback:&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">telemetry</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_telemetry</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load telemetry data!&quot;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Telemetry data failure traceback:&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">weather</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_weather_data</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load weather data!&quot;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Weather data failure traceback:&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">messages</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_race_control_messages</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load Race Control message &quot;</span>
                                    <span class="s2">&quot;data!&quot;</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;RC message data failure traceback:&quot;</span><span class="p">,</span>
                                  <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">laps</span><span class="p">,</span> <span class="n">telemetry</span><span class="p">,</span> <span class="n">weather</span><span class="p">,</span> <span class="n">messages</span><span class="p">)):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot load laps, telemetry, weather, and message data &quot;</span>
                    <span class="s2">&quot;because the relevant API is not supported for this &quot;</span>
                    <span class="s2">&quot;session.&quot;</span>
                <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished loading data for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;drivers: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Session.load_laps"><a class="viewcode-back" href="../../core.html#fastf1.Session.load_laps">[docs]</a>    <span class="k">def</span> <span class="nf">load_laps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_telemetry</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            use :func:`Session.load` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`Session.load_laps` is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Session.load` instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">telemetry</span><span class="o">=</span><span class="n">with_telemetry</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">laps</span></div>

<div class="viewcode-block" id="Session.load_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Session.load_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">load_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            use :func:`Session.load` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`Session.load_laps` is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Session.load` instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_telemetry</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_load_laps_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="p">):</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">timing_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">app_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">timing_app_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Processing timing data...&quot;</span><span class="p">)</span>
        <span class="c1"># Matching data and app_data. Not super straightforward</span>
        <span class="c1"># Sometimes a car may enter the pit without changing tyres, so</span>
        <span class="c1"># new compound is associated with the help of logging time.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;NumberOfPitStops&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="n">app_data</span><span class="p">[[</span><span class="s1">&#39;Driver&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;Compound&#39;</span><span class="p">,</span> <span class="s1">&#39;StartLaps&#39;</span><span class="p">,</span> <span class="s1">&#39;New&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;Stint&#39;</span><span class="p">]]</span>
        <span class="n">useful</span> <span class="o">=</span> <span class="n">useful</span><span class="p">[</span><span class="o">~</span><span class="n">useful</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
        <span class="c1"># check when a session was started; for a race this indicates the</span>
        <span class="c1"># start of the race</span>
        <span class="n">session_status</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">session_status_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span>
                                                 <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Started&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_session_start_time</span> <span class="o">=</span> <span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to determine `Session.session_start_time`&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_session_start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_session_status</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">session_status</span><span class="p">)</span>

        <span class="c1"># Lap count data only exists for race-like sessions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Race&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint Qualifying&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lap_count</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">lap_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
                <span class="c1"># A race-like session can have multiple intended total laps,</span>
                <span class="c1"># the first one being the original schedule</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_total_laps</span> <span class="o">=</span> <span class="n">lap_count</span><span class="p">[</span><span class="s1">&#39;TotalLaps&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_total_laps</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No lap count data for this session.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_total_laps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">df</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">track_status</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">track_status_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_status</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">track_status</span><span class="p">)</span>

        <span class="n">drivers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">drivers</span><span class="p">:</span>
            <span class="c1"># no driver list, generate from lap data</span>
            <span class="n">drivers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> \
                <span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">useful</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()))</span>

            <span class="n">_nums_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">drivers</span><span class="p">)},</span>
                                    <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">drivers</span><span class="p">))</span>
            <span class="n">_info_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">fastf1</span><span class="o">.</span><span class="n">_DRIVER_TEAM_MAPPING</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">SessionResults</span><span class="p">(</span><span class="n">_nums_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_info_df</span><span class="p">),</span>
                                           <span class="n">force_default_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Generating minimal driver &quot;</span>
                            <span class="s2">&quot;list from timing data.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">driver</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">drivers</span><span class="p">):</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">driver</span><span class="p">]</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">useful</span><span class="p">[</span><span class="n">useful</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">driver</span><span class="p">]</span>
            <span class="c1"># TODO: replace number of pitstops with stint?</span>
            <span class="k">if</span> <span class="n">d2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
                <span class="c1"># tyre info includes correction messages that need to be</span>
                <span class="c1"># applied before continuing</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fix_tyre_info</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>
            <span class="n">only_one_lap</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Race&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint Qualifying&#39;</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)):</span>
                    <span class="c1"># add data for drivers who crashed on the very first lap</span>
                    <span class="c1"># as a downside, this potentially adds a nonexistent lap</span>
                    <span class="c1"># for drivers who could not start the race</span>
                    <span class="n">only_one_lap</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">driver</span><span class="p">,</span> <span class="p">]</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;NumberOfLaps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;IsPersonalBest&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;TyreLife&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span><span class="p">[</span><span class="s1">&#39;StartLaps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">result</span><span class="p">[</span><span class="s1">&#39;New&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span><span class="p">[</span><span class="s1">&#39;New&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No lap data for driver </span><span class="si">{</span><span class="n">driver</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>  <span class="c1"># no data for this driver; skip</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">()</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;TyreLife&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;New&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No tyre data for driver </span><span class="si">{</span><span class="n">driver</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="s1">&#39;Driver&#39;</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;StartLaps&#39;</span><span class="p">:</span> <span class="s1">&#39;TyreLife&#39;</span><span class="p">})</span>

            <span class="c1"># calculate lap start time by setting it to the &#39;Time&#39; of the</span>
            <span class="c1"># previous lap</span>
            <span class="n">laps_start_time</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Race&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint Qualifying&#39;</span><span class="p">):</span>
                <span class="c1"># assumption that the first lap started when the session was</span>
                <span class="c1"># started can only be made for the race</span>
                <span class="n">laps_start_time</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_start_time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">laps_start_time</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">)</span>
            <span class="n">laps_start_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">laps_start_time</span><span class="p">)</span>

            <span class="c1"># don&#39;t set lap start times after red flag restart to the time</span>
            <span class="c1"># at which the previous lap was set</span>
            <span class="c1"># only run this correction if the session was ever aborted</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Aborted&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_is_aborted</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># first, find the point at which the session was aborted, then</span>
                <span class="c1"># the following restart and the lap that starts immediately</span>
                <span class="c1"># after; correct its pit out time</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">_is_aborted</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Started&#39;</span><span class="p">:</span>  <span class="c1"># restart</span>
                        <span class="n">_is_aborted</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">restart_index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                <span class="n">result</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">],</span>
                                <span class="s1">&#39;PitOutTime&#39;</span>
                            <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                            <span class="k">continue</span>  <span class="c1"># no pit out, car did not restart</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Sprint Qualifying&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;Race&#39;</span><span class="p">):</span>
                            <span class="c1"># if this is a race-like session, we can assume the</span>
                            <span class="c1"># session restart time as lap start time</span>
                            <span class="n">laps_start_time</span><span class="p">[</span><span class="n">restart_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># for other sessions, we cannot make this</span>
                            <span class="c1"># assumption set to NaT here, it will be set to</span>
                            <span class="c1"># PitOutTime later if possible</span>
                            <span class="n">laps_start_time</span><span class="p">[</span><span class="n">restart_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span>
                    <span class="k">elif</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Aborted&#39;</span><span class="p">:</span>  <span class="c1"># red flag</span>
                        <span class="n">_is_aborted</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">laps_start_time</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;timedelta64[ns]&#39;</span>
            <span class="p">)</span>

            <span class="c1"># set missing lap start times to pit out time where possible</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">]))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;PitOutTime&#39;</span><span class="p">]</span>

            <span class="c1"># create total laps counter for each tyre used</span>
            <span class="k">for</span> <span class="n">npit</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">sel</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">npit</span>
                <span class="n">result</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TyreLife&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sel</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># check if there is another lap during which the session was aborted</span>
            <span class="c1"># but which is not in the data</span>
            <span class="c1"># if yes, add as much data as possible for it</span>
            <span class="c1"># set the time of abort as lap end time given that there is no</span>
            <span class="c1"># accurate time available</span>
            <span class="c1"># this block of code has no tests; testing would require to mock</span>
            <span class="c1"># the data as the actual data may be updated on the server after</span>
            <span class="c1"># some time and the problem no longer occurs</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;PitInTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">only_one_lap</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">next_statuses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_statuses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">session_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
                        <span class="o">&gt;</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">]</span>

                <span class="n">aborted</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">next_statuses</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">next_status</span> <span class="o">=</span> <span class="n">next_statuses</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">aborted</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Aborted&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">aborted</span><span class="p">:</span>
                    <span class="n">new_last</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                        <span class="s1">&#39;LapStartTime&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s1">&#39;Time&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">next_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]],</span>
                        <span class="s1">&#39;Driver&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s1">&#39;NumberOfLaps&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;NumberOfLaps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;Stint&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="c1"># &#39;IsPersonalBest&#39;: False,</span>
                        <span class="s1">&#39;Compound&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s1">&#39;TyreLife&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;TyreLife&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="s1">&#39;New&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;New&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="p">})</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">only_one_lap</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">result</span><span class="p">,</span> <span class="n">new_last</span><span class="p">])</span> \
                            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">new_last</span>

            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">result</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoLapDataError</span>
        <span class="n">laps</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># noqa: F821</span>
        <span class="n">laps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Driver&#39;</span><span class="p">:</span> <span class="s1">&#39;DriverNumber&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;NumberOfLaps&#39;</span><span class="p">:</span> <span class="s1">&#39;LapNumber&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;New&#39;</span><span class="p">:</span> <span class="s1">&#39;FreshTyre&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counting stints from 1</span>
        <span class="n">t_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]:</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;TeamName&#39;</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()}</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">t_map</span><span class="p">)</span>
        <span class="n">d_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]:</span> <span class="n">r</span><span class="p">[</span><span class="s1">&#39;Abbreviation&#39;</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()}</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">d_map</span><span class="p">)</span>

        <span class="c1"># add track status data</span>
        <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>

        <span class="k">def</span> <span class="nf">applicator</span><span class="p">(</span><span class="n">new_status</span><span class="p">,</span> <span class="n">current_status</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">current_status</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_status</span>
            <span class="k">elif</span> <span class="n">new_status</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_status</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current_status</span> <span class="o">+</span> <span class="n">new_status</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">current_status</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">track_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">track_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">track_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">next_t</span><span class="p">,</span> <span class="n">next_status</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">track_status</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="n">track_status</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">if</span> <span class="n">status</span> <span class="o">!=</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="c1"># status change partially in lap partially outside</span>
                    <span class="n">sel</span> <span class="o">=</span> <span class="p">(((</span><span class="n">next_t</span> <span class="o">&gt;=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">])</span>
                            <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">))</span>
                           <span class="o">|</span> <span class="p">((</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">next_t</span><span class="p">)))</span>
                    <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># status change two times in one lap (e.g. short yellow flag)</span>
                    <span class="n">sel</span> <span class="o">=</span> <span class="p">((</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">next_t</span><span class="p">))</span>
                    <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">t</span> <span class="o">=</span> <span class="n">next_t</span>
                <span class="n">status</span> <span class="o">=</span> <span class="n">next_status</span>

            <span class="n">sel</span> <span class="o">=</span> <span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t</span>
            <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">,</span> <span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">curr</span><span class="p">:</span> <span class="n">applicator</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Could not load any valid session status information!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span> <span class="o">=</span> <span class="n">Laps</span><span class="p">(</span><span class="n">laps</span><span class="p">,</span> <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_lap_accuracy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fix_tyre_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="c1"># Sometimes later corrections of tyre info are sent through the api.</span>
        <span class="c1"># These updates only set values that need to be changed and all other</span>
        <span class="c1"># values are none-like. Therefore, if correction updates exist, for</span>
        <span class="c1"># each stint the first received information is taken and then</span>
        <span class="c1"># iteratively updated with non-NA values from all updates for this</span>
        <span class="c1"># stint (in the order received).</span>
        <span class="n">corrected</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span><span class="s1">&#39;Stint&#39;</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()},</span> <span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Stint&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">stint</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># iterate over all messages (rows) that were received for this</span>
                <span class="c1"># stint</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">corrected</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># first message: set as a whole (performance)</span>
                    <span class="n">corrected</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># correction: update existing values only if new value</span>
                    <span class="c1"># is non-na</span>
                    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;Time&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">corrected</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">]):</span>
                        <span class="c1"># always keep first time stamp instead of corrected</span>
                        <span class="c1"># corresponds to pit stop time</span>
                        <span class="k">continue</span>
                    <span class="n">corrected</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># reapply original dtypes per column</span>
        <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">):</span>
            <span class="n">corrected</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrected</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">corrected</span>

    <span class="k">def</span> <span class="nf">_check_lap_accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accuracy validation; simples yes/no validation</span>
<span class="sd">        Currently only relies on provided information which can&#39;t catch all problems&quot;&quot;&quot;</span>
        <span class="c1"># TODO: check for outliers in lap start position</span>
        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="n">is_accurate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">prev_lap</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">integrity_errors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># require existence, non-existence and specific values for some variables</span>
                <span class="n">check_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;PitInTime&#39;</span><span class="p">])</span>
                           <span class="o">&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">])</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">))</span>  <span class="c1"># slightly paranoid, allow only green and yellow flag</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector1Time&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector2Time&#39;</span><span class="p">]))</span>
                           <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector3Time&#39;</span><span class="p">])))</span>

                <span class="k">if</span> <span class="n">check_1</span><span class="p">:</span>  <span class="c1"># only do check 2 if all necessary values for this check are even available</span>
                    <span class="c1"># sum of sector times should be almost equal to lap time (tolerance 3ms)</span>
                    <span class="n">check_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector1Time&#39;</span><span class="p">],</span> <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector2Time&#39;</span><span class="p">],</span>
                                                  <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;Sector3Time&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span>
                                          <span class="n">lap</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">(),</span>
                                          <span class="n">atol</span><span class="o">=</span><span class="mf">0.003</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">check_2</span><span class="p">:</span>
                        <span class="n">integrity_errors</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check_2</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># data not available means fail</span>

                <span class="k">if</span> <span class="n">prev_lap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># first lap after safety car often has timing issues (as do all laps under safety car)</span>
                    <span class="n">check_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_lap</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;4&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">check_3</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># no previous lap, no SC error</span>

                <span class="n">result</span> <span class="o">=</span> <span class="n">check_1</span> <span class="ow">and</span> <span class="n">check_2</span> <span class="ow">and</span> <span class="n">check_3</span>
                <span class="n">is_accurate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">prev_lap</span> <span class="o">=</span> <span class="n">lap</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_accurate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">drv</span><span class="p">,</span> <span class="s1">&#39;IsAccurate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_accurate</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to perform lap accuracy check - all &quot;</span>
                                <span class="s2">&quot;laps marked as inaccurate.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;IsAccurate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># default should be inaccurate</span>

            <span class="c1"># necessary to explicitly cast to bool</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="p">[[</span><span class="s1">&#39;IsAccurate&#39;</span><span class="p">]]</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="p">[[</span><span class="s1">&#39;IsAccurate&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">integrity_errors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Driver </span><span class="si">{</span><span class="n">drv</span><span class="si">:</span><span class="s2"> &gt;2</span><span class="si">}</span><span class="s2">: Lap timing integrity check failed for </span><span class="si">{</span><span class="n">integrity_errors</span><span class="si">}</span><span class="s2"> lap(s)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_drivers_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># get list of drivers</span>
        <span class="n">driver_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f1_api_support</span><span class="p">:</span>
            <span class="c1"># load driver info from f1 api</span>
            <span class="n">driver_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drivers_from_f1_api</span><span class="p">(</span><span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">driver_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">is_testing</span><span class="p">():</span>
                <span class="c1"># load driver info and results from ergast</span>
                <span class="c1"># (season 2017 and older or fallback from f1 api)</span>
                <span class="n">driver_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drivers_results_from_ergast</span><span class="p">(</span>
                    <span class="n">load_drivers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">load_results</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">SessionResults</span><span class="p">(</span>
                    <span class="n">driver_info</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">driver_info</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">],</span>
                    <span class="n">force_default_cols</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load driver list and &quot;</span>
                                <span class="s2">&quot;session results!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">SessionResults</span><span class="p">(</span><span class="n">force_default_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># extend existing driver info (f1 api) with results from ergast</span>
            <span class="n">drivers</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">driver_info</span><span class="p">,</span>
                                   <span class="n">index</span><span class="o">=</span><span class="n">driver_info</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">is_testing</span><span class="p">():</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drivers_results_from_ergast</span><span class="p">(</span><span class="n">load_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                <span class="c1"># join driver info and session results</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">SessionResults</span><span class="p">(</span>
                    <span class="n">drivers</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">),</span> <span class="n">force_default_cols</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># return driver info without session results</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="n">SessionResults</span><span class="p">(</span><span class="n">drivers</span><span class="p">,</span>
                                               <span class="n">force_default_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dupl_mask</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">())</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">dupl_drv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">dupl_mask</span><span class="p">])</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Session results contain duplicate entries for &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;driver(s) </span><span class="si">{</span><span class="n">dupl_drv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;Position&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;Position&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_drivers_from_f1_api</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f1di</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">driver_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load extended driver information!&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Exception while loading driver list&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>
            <span class="n">driver_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">driver_info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="ow">in</span> <span class="p">{</span>
                <span class="s1">&#39;RacingNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;DriverNumber&#39;</span><span class="p">,</span>
                <span class="s1">&#39;BroadcastName&#39;</span><span class="p">:</span> <span class="s1">&#39;BroadcastName&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Tla&#39;</span><span class="p">:</span> <span class="s1">&#39;Abbreviation&#39;</span><span class="p">,</span> <span class="s1">&#39;TeamName&#39;</span><span class="p">:</span> <span class="s1">&#39;TeamName&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TeamColour&#39;</span><span class="p">:</span> <span class="s1">&#39;TeamColor&#39;</span><span class="p">,</span> <span class="s1">&#39;FirstName&#39;</span><span class="p">:</span> <span class="s1">&#39;FirstName&#39;</span><span class="p">,</span>
                <span class="s1">&#39;LastName&#39;</span><span class="p">:</span> <span class="s1">&#39;LastName&#39;</span>
            <span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">f1di</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">driver_info</span><span class="p">[</span><span class="n">key2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key1</span><span class="p">))</span>
            <span class="k">if</span> <span class="s1">&#39;FirstName&#39;</span> <span class="ow">in</span> <span class="n">driver_info</span> <span class="ow">and</span> <span class="s1">&#39;LastName&#39;</span> <span class="ow">in</span> <span class="n">driver_info</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">driver_info</span><span class="p">[</span><span class="s1">&#39;FirstName&#39;</span><span class="p">],</span>
                                       <span class="n">driver_info</span><span class="p">[</span><span class="s1">&#39;LastName&#39;</span><span class="p">]):</span>
                    <span class="n">driver_info</span><span class="p">[</span><span class="s1">&#39;FullName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">first</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">last</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">driver_info</span>

    <span class="k">def</span> <span class="nf">_drivers_results_from_ergast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">load_drivers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">load_results</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Qualifying&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint Qualifying&#39;</span><span class="p">,</span> <span class="s1">&#39;Sprint&#39;</span><span class="p">,</span> <span class="s1">&#39;Race&#39;</span><span class="p">):</span>
            <span class="n">session_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this is a practice session, use drivers from race session but</span>
            <span class="c1"># don&#39;t load results</span>
            <span class="n">session_name</span> <span class="o">=</span> <span class="s1">&#39;Race&#39;</span>
            <span class="n">load_results</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ergast</span><span class="o">.</span><span class="n">fetch_results</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="s1">&#39;RoundNumber&#39;</span><span class="p">],</span> <span class="n">session_name</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to load data from Ergast API! &quot;</span>
                            <span class="s2">&quot;(This is expected for recent sessions)&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ergast failure traceback:&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d</span>

        <span class="n">time0</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_drivers</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Abbreviation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Driver&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">,</span>
                                       <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">first_name</span> <span class="o">=</span> <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Driver&#39;</span><span class="p">,</span> <span class="s1">&#39;givenName&#39;</span><span class="p">,</span>
                                                <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">last_name</span> <span class="o">=</span> <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Driver&#39;</span><span class="p">,</span> <span class="s1">&#39;familyName&#39;</span><span class="p">,</span>
                                               <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;FirstName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_name</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;LastName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_name</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;FullName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">first_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">last_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;TeamName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Constructor&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>
                                       <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">load_results</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;position&#39;</span><span class="p">))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;GridPosition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Q1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Q1&#39;</span><span class="p">)))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Q2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Q2&#39;</span><span class="p">)))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Q3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Q3&#39;</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">time0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ts</span> <span class="o">=</span> <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                                            <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="n">time0</span> <span class="o">=</span> <span class="n">to_timedelta</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">time0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ts</span> <span class="o">=</span> <span class="n">recursive_dict_get</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span>
                                            <span class="n">default_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ts</span><span class="p">:</span>
                        <span class="n">dt</span> <span class="o">=</span> <span class="n">to_timedelta</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time0</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Status&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;Points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;points&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_load_weather_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">weather_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">weather_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">weather_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">weather_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weather_data</span> <span class="o">=</span> <span class="n">weather_df</span>

    <span class="k">def</span> <span class="nf">_load_race_control_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">race_control_messages</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">race_control_messages</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span>
                                                          <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">race_control_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">race_control_messages</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_race_control_messages</span> <span class="o">=</span> <span class="n">race_control_df</span>

    <span class="k">def</span> <span class="nf">_load_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load telemetry data from the API.</span>

<span class="sd">        This method can only be called after :meth:`load_laps` has been</span>
<span class="sd">        called. You will usually just want to call :meth:`load_laps` with</span>
<span class="sd">        the optional ``with_telemetry=True`` argument instead of calling this</span>
<span class="sd">        method separately. The result will be the same.</span>

<span class="sd">        The raw data is divided into car data (Speed, RPM, ...) and position data (coordinates, on/off track). For each</span>
<span class="sd">        of the two types an instance of :class:`Telemetry` is created per driver. The properties</span>
<span class="sd">        :attr:`Session.car_data` and :attr:`Session.pos_data` are dictionaries which hold the the `Telemetry` objects</span>
<span class="sd">        keyed by driver number.</span>

<span class="sd">        The telemetry data can either be accessed through the above mentioned attributes or conveniently on a per</span>
<span class="sd">        lap basis through :class:`Lap` and :class:`Laps`. See :class:`Telemetry` on how to work with the telemetry</span>
<span class="sd">        data.</span>

<span class="sd">        Note that this method additionally calculates :attr:`Session.t0_date` and adds a `LapStartDate` column to</span>
<span class="sd">        :attr:`Session.laps`.</span>

<span class="sd">        Args:</span>
<span class="sd">            livedata (:class:`fastf1.livetiming.data.LiveTimingData`, optional) :</span>
<span class="sd">                instead of requesting the data from the api, locally saved</span>
<span class="sd">                livetiming data can be used as a data source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">car_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">position_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api_path</span><span class="p">,</span> <span class="n">livedata</span><span class="o">=</span><span class="n">livedata</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_t0_date</span><span class="p">(</span><span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_car_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">drivers</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># drop and recalculate time stamps based on &#39;Date&#39;, because &#39;Date&#39; has a higher resolution</span>
                <span class="n">drv_car</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">drv</span><span class="p">,</span>
                                    <span class="n">drop_unknown_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">drv_pos</span> <span class="o">=</span> <span class="n">Telemetry</span><span class="p">(</span><span class="n">pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">drv</span><span class="p">,</span>
                                    <span class="n">drop_unknown_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># not pos data or car data exists for this driver</span>
                <span class="k">continue</span>

            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span>

            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span>  <span class="c1"># create proper continuous timestamps</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span>
            <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
            <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;SessionTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_car_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_car</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos_data</span><span class="p">[</span><span class="n">drv</span><span class="p">]</span> <span class="o">=</span> <span class="n">drv_pos</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="p">[</span><span class="s1">&#39;LapStartDate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_laps</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0_date</span>

<div class="viewcode-block" id="Session.get_driver"><a class="viewcode-back" href="../../core.html#fastf1.Session.get_driver">[docs]</a>    <span class="k">def</span> <span class="nf">get_driver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Driver&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a driver object which contains additional information about a driver.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier (str): driver&#39;s three letter identifier (for</span>
<span class="sd">                example &#39;VER&#39;) or driver number as string</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Driver`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;Abbreviation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid driver identifier &#39;</span><span class="si">{</span><span class="n">identifier</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_calculate_t0_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the date timestamp at which data for this session is starting.</span>

<span class="sd">        This does not mark the start of a race (or other sessions). This marks the start of the data which is sometimes</span>
<span class="sd">        far before.</span>

<span class="sd">        This function sets :attr:`self.t0_date` which is an internally required offset for some calculations.</span>

<span class="sd">        The current assumption is that the latest date which can be calculated is correct. (Based on the timestamp with</span>
<span class="sd">        the least delay.)</span>

<span class="sd">        Args:</span>
<span class="sd">            car_data: Car telemetry; should contain all samples and only original ones</span>
<span class="sd">            pos_data: Car position data; should contain all samples and only original ones</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">date_offset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="p">(</span><span class="n">car_data</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">drv</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">new_offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">drv</span><span class="p">][</span><span class="s1">&#39;Date&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">drv</span><span class="p">][</span><span class="s1">&#39;Time&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">date_offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_offset</span> <span class="o">&gt;</span> <span class="n">date_offset</span><span class="p">:</span>
                    <span class="n">date_offset</span> <span class="o">=</span> <span class="n">new_offset</span>

        <span class="k">if</span> <span class="n">date_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t0_date</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Failed to determine `Session.t0_date`!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t0_date</span> <span class="o">=</span> <span class="n">date_offset</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s1">&#39;ms&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Laps"><a class="viewcode-back" href="../../core.html#fastf1.Laps">[docs]</a><span class="k">class</span> <span class="nc">Laps</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing lap (timing) data of multiple laps.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args (any): passed through to :class:`pandas.DataFrame` super class</span>
<span class="sd">        session (:class:`Session`): instance of session class; required for</span>
<span class="sd">          full functionality</span>
<span class="sd">        **kwargs (any): passed through to :class:`pandas.DataFrame`</span>
<span class="sd">          super class</span>

<span class="sd">    This class allows for easily picking specific laps from all laps in a</span>
<span class="sd">    session. It implements some additional functionality on top off the usual</span>
<span class="sd">    `pandas.DataFrame` functionality. Among others, the laps&#39; associated</span>
<span class="sd">    telemetry data can be accessed.</span>

<span class="sd">    If for example you want to get the fastest lap of Bottas you can narrow</span>
<span class="sd">    it down like this::</span>

<span class="sd">        import fastf1</span>

<span class="sd">        session = fastf1.get_session(2019, &#39;Bahrain&#39;, &#39;Q&#39;)</span>
<span class="sd">        session.load()</span>
<span class="sd">        best_bottas = session.laps.pick_driver(&#39;BOT&#39;).pick_fastest()</span>

<span class="sd">        print(best_bottas[&#39;LapTime&#39;])</span>
<span class="sd">        # Timedelta(&#39;0 days 00:01:28.256000&#39;)</span>

<span class="sd">    Slicing this class will return :class:`Laps` again for slices containing</span>
<span class="sd">    multiple rows. Single rows will be returned as :class:`Lap`.</span>

<span class="sd">    The following information is available per lap (one DataFrame column</span>
<span class="sd">    for each):</span>

<span class="sd">        - **Time** (pandas.Timedelta): Session time when the lap time was</span>
<span class="sd">          set (end of lap)</span>
<span class="sd">        - **Driver** (string): Three letter driver identifier</span>
<span class="sd">        - **DriverNumber** (str): Driver number</span>
<span class="sd">        - **LapTime** (pandas.Timedelta): Recorded lap time.</span>
<span class="sd">          Officially deleted lap times will *not* be deleted here.</span>
<span class="sd">          Deleting laps is currently not supported.</span>
<span class="sd">        - **LapNumber** (int): Recorded lap number</span>
<span class="sd">        - **Stint** (int): Stint number</span>
<span class="sd">        - **PitOutTime** (pandas.Timedelta): Session time when car exited</span>
<span class="sd">          the pit</span>
<span class="sd">        - **PitInTime** (pandas.Timedelta): Session time when car entered</span>
<span class="sd">          the pit</span>
<span class="sd">        - **Sector1Time** (pandas.Timedelta): Sector 1 recorded time</span>
<span class="sd">        - **Sector2Time** (pandas.Timedelta): Sector 2 recorded time</span>
<span class="sd">        - **Sector3Time** (pandas.Timedelta): Sector 3 recorded time</span>
<span class="sd">        - **Sector1SessionTime** (pandas.Timedelta): Session time when the</span>
<span class="sd">          Sector 1 time was set</span>
<span class="sd">        - **Sector2SessionTime** (pandas.Timedelta): Session time when the</span>
<span class="sd">          Sector 2 time was set</span>
<span class="sd">        - **Sector3SessionTime** (pandas.Timedelta): Session time when the</span>
<span class="sd">          Sector 3 time was set</span>
<span class="sd">        - **SpeedI1** (float): Speedtrap sector 1 [km/h]</span>
<span class="sd">        - **SpeedI2** (float): Speedtrap sector 2 [km/h]</span>
<span class="sd">        - **SpeedFL** (float): Speedtrap at finish line [km/h]</span>
<span class="sd">        - **SpeedST** (float): Speedtrap on longest straight (Not sure) [km/h]</span>
<span class="sd">        - **IsPersonalBest** (bool): Flag that indicates whether this lap is</span>
<span class="sd">          the official personal best lap of a driver. If any lap of a driver</span>
<span class="sd">          is quicker than their respective personal best lap, this means that</span>
<span class="sd">          the quicker lap is invalid and not counted. For example, this can</span>
<span class="sd">          happen if the track limits were exceeded.</span>
<span class="sd">        - **Compound** (str): Tyres event specific compound name: SOFT, MEDIUM,</span>
<span class="sd">          HARD, INTERMEDIATE, WET (the actual underlying compounds C1 to C5 are</span>
<span class="sd">          not differentiated).</span>
<span class="sd">        - **TyreLife** (float): Laps driven on this tire (includes laps in</span>
<span class="sd">          other sessions for used sets of tires)</span>
<span class="sd">        - **FreshTyre** (bool): Tyre had TyreLife=0 at stint start, i.e.</span>
<span class="sd">          was a new tire</span>
<span class="sd">        - **Team** (str): Team name</span>
<span class="sd">        - **LapStartTime** (pandas.Timedelta): Session time at the start of</span>
<span class="sd">          the lap</span>
<span class="sd">        - **LapStartDate** (pandas.Timestamp): Timestamp at the start of</span>
<span class="sd">          the lap</span>
<span class="sd">        - **TrackStatus** (str): A string that contains track status numbers</span>
<span class="sd">          for all track status that occurred</span>
<span class="sd">          during this lap. The meaning of the track status numbers is</span>
<span class="sd">          explained in :func:`fastf1.api.track_status_data`.</span>
<span class="sd">          For filtering laps by track status, you may want to use</span>
<span class="sd">          :func:`Laps.pick_track_status`.</span>
<span class="sd">        - **IsAccurate** (bool): Indicates that the lap start and end time are</span>
<span class="sd">          synced correctly with other laps. Do not confuse this with the</span>
<span class="sd">          accuracy of the lap time or sector times. They are always considered</span>
<span class="sd">          to be accurate if they exist!</span>
<span class="sd">          If this value is True, the lap has passed as basic accuracy check</span>
<span class="sd">          for timing data. This does not guarantee accuracy but laps marked</span>
<span class="sd">          as inaccurate need to be handled with caution. They might contain</span>
<span class="sd">          errors which can not be spotted easily.</span>
<span class="sd">          Laps need to satisfy the following criteria to be marked</span>
<span class="sd">          as accurate:</span>

<span class="sd">            - not an inlap or outlap</span>
<span class="sd">            - set under green or yellow flag (the api sometimes has issues</span>
<span class="sd">              with data from SC/VSC laps)</span>
<span class="sd">            - is not the first lap after a safety car period</span>
<span class="sd">              (issues with SC/VSC might still appear on the first lap</span>
<span class="sd">              after it has ended)</span>
<span class="sd">            - has a value for lap time and all sector times</span>
<span class="sd">            - the sum of the sector times matches the lap time</span>
<span class="sd">              (If this were to ever occur, it would also be logged separately</span>
<span class="sd">              as a data integrity error. You usually don&#39;t need to worry about</span>
<span class="sd">              this.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span>

    <span class="n">QUICKLAP_THRESHOLD</span> <span class="o">=</span> <span class="mf">1.07</span>
    <span class="sd">&quot;&quot;&quot;Used to determine &#39;quick&#39; laps. Defaults to the 107% rule.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">session</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Session</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Laps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Lap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_class_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a nicer debugging experience; can now view as</span>
<span class="sd">        dataframe in various IDEs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for all laps in `self`</span>

<span class="sd">        This is a cached (!) property for :meth:`get_telemetry`. It will return the same value as `get_telemetry`</span>
<span class="sd">        but cache the result so that the involved processing is only done once.</span>

<span class="sd">        This is mainly provided for convenience and backwards compatibility.</span>

<span class="sd">        See :meth:`get_telemetry` for more information.</span>

<span class="sd">        .. note:: Telemetry can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_telemetry</span><span class="p">()</span>

<div class="viewcode-block" id="Laps.get_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for all laps in `self`</span>

<span class="sd">        Telemetry data is the result of merging the returned data from :meth:`get_car_data` and :meth:`get_pos_data`.</span>
<span class="sd">        This means that telemetry data at least partially contains interpolated values! Telemetry data additionally</span>
<span class="sd">        already has computed channels added (e.g. Distance).</span>

<span class="sd">        This method is provided for convenience and compatibility reasons. But using it does usually not produce</span>
<span class="sd">        the most accurate possible result.</span>
<span class="sd">        It is recommended to use :meth:`get_car_data` or :meth:`get_pos_data` when possible. This is also faster if</span>
<span class="sd">        merging of car and position data is not necessary and if not all computed channels are needed.</span>

<span class="sd">        Resampling during merging is done according to the frequency set by :attr:`TELEMETRY_FREQUENCY`.</span>

<span class="sd">        .. note:: Telemetry can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_car_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>

        <span class="c1"># calculate driver ahead from data without padding to</span>
        <span class="c1"># prevent out of bounds errors</span>
        <span class="n">drv_ahead</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
            <span class="o">.</span><span class="n">add_driver_ahead</span><span class="p">()</span> \
            <span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">,</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;SessionTime&#39;</span><span class="p">)]</span>

        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_relative_distance</span><span class="p">()</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">drv_ahead</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">car_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Laps.get_car_data"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_car_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_car_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Car data for all laps in `self`</span>

<span class="sd">        Slices the car data in :attr:`Session.car_data` using this set of laps and returns the result.</span>

<span class="sd">        The data returned by this method does not contain computed telemetry channels. The can be added by calling the</span>
<span class="sd">        appropriate `add_*()` method on the returned telemetry object..</span>

<span class="sd">        .. note:: Car data can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains no driver number!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains Laps of multiple drivers!&quot;</span><span class="p">)</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="n">drv_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="n">drv_num</span><span class="p">]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">car_data</span></div>

<div class="viewcode-block" id="Laps.get_pos_data"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_pos_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pos data for all laps in `self`</span>

<span class="sd">        Slices the position data in :attr:`Session.pos_data` using this set of laps and returns the result.</span>

<span class="sd">        .. note:: Position data can only be returned if `self` contains laps of one driver only.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains no driver number!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">drv_num</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice telemetry because self contains Laps of multiple drivers!&quot;</span><span class="p">)</span>
        <span class="n">drv_num</span> <span class="o">=</span> <span class="n">drv_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">pos_data</span><span class="p">[</span><span class="n">drv_num</span><span class="p">]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos_data</span></div>

<div class="viewcode-block" id="Laps.get_weather_data"><a class="viewcode-back" href="../../core.html#fastf1.Laps.get_weather_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_weather_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return weather data for each lap in self.</span>

<span class="sd">        Weather data is updated once per minute. This means that there are</span>
<span class="sd">        usually one or two data points per lap. This function will always</span>
<span class="sd">        return only one data point per lap:</span>

<span class="sd">           - The first value within the duration of a lap</span>

<span class="sd">        or</span>

<span class="sd">            - the last known value before the end of the lap if there are</span>
<span class="sd">              no values within the duration of a lap</span>

<span class="sd">        See :func:`fastf1.api.weather_data` for available data</span>
<span class="sd">        channels.</span>

<span class="sd">        If you wish to have more control over the data, you can access the</span>
<span class="sd">        weather data directly in :attr:`Session.weather_data`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.DataFrame</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; session = fastf1.get_session(2019, &#39;Monza&#39;, &#39;Q&#39;)</span>
<span class="sd">            &gt;&gt;&gt; session.load(telemetry=False)</span>
<span class="sd">            &gt;&gt;&gt; weather_data = session.laps.get_weather_data()</span>
<span class="sd">            &gt;&gt;&gt; print(weather_data)</span>
<span class="sd">                                 Time AirTemp Humidity  ... TrackTemp WindDirection WindSpeed</span>
<span class="sd">            20 0 days 00:20:14.613000    22.5     52.0  ...      35.8           212       2.0</span>
<span class="sd">            21 0 days 00:21:15.001000    22.5     52.2  ...      36.1           207       2.7</span>
<span class="sd">            23 0 days 00:23:14.854000    22.7     52.5  ...      37.4           210       2.3</span>
<span class="sd">            24 0 days 00:24:14.430000    23.2     51.5  ...      37.4           207       3.2</span>
<span class="sd">            26 0 days 00:26:14.315000    23.6     50.2  ...      37.2           238       1.8</span>
<span class="sd">            ..                    ...     ...      ...  ...       ...           ...       ...</span>
<span class="sd">            36 0 days 00:36:14.426000    23.0     51.1  ...      38.3           192       0.9</span>
<span class="sd">            37 0 days 00:37:14.391000    23.3     50.0  ...      38.7           213       0.9</span>
<span class="sd">            28 0 days 00:28:14.324000    23.5     49.9  ...      37.5           183       1.3</span>
<span class="sd">            34 0 days 00:34:14.385000    23.0     51.7  ...      37.7           272       0.8</span>
<span class="sd">            35 0 days 00:35:14.460000    23.2     50.3  ...      38.0           339       1.1</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            [275 rows x 8 columns]</span>

<span class="sd">        Joining weather data with lap timing data:</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; import pandas as pd  # needed additionally to fastf1</span>

<span class="sd">            # prepare the data for joining</span>
<span class="sd">            &gt;&gt;&gt; laps = session.laps</span>
<span class="sd">            &gt;&gt;&gt; laps = laps.reset_index(drop=True)</span>
<span class="sd">            &gt;&gt;&gt; weather_data = weather_data.reset_index(drop=True)</span>

<span class="sd">            # exclude the &#39;Time&#39; column from weather data when joining</span>
<span class="sd">            &gt;&gt;&gt; joined = pd.concat([laps, weather_data.loc[:, ~(weather_data.columns == &#39;Time&#39;)]], axis=1)</span>
<span class="sd">            &gt;&gt;&gt; print(joined)</span>
<span class="sd">                                  Time DriverNumber  ... WindDirection  WindSpeed</span>
<span class="sd">            0   0 days 00:21:01.358000           16  ...           212        2.0</span>
<span class="sd">            1   0 days 00:22:21.775000           16  ...           207        2.7</span>
<span class="sd">            2   0 days 00:24:03.991000           16  ...           210        2.3</span>
<span class="sd">            3   0 days 00:25:24.117000           16  ...           207        3.2</span>
<span class="sd">            4   0 days 00:27:09.461000           16  ...           238        1.8</span>
<span class="sd">            ..                     ...          ...  ...           ...        ...</span>
<span class="sd">            270 0 days 00:36:38.150000           88  ...           192        0.9</span>
<span class="sd">            271 0 days 00:38:37.508000           88  ...           213        0.9</span>
<span class="sd">            272 0 days 00:33:27.227000           33  ...           183        1.3</span>
<span class="sd">            273 0 days 00:35:05.865000           33  ...           272        0.8</span>
<span class="sd">            274 0 days 00:36:47.787000           33  ...           339        1.1</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            [275 rows x 33 columns]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wd</span> <span class="o">=</span> <span class="p">[</span><span class="n">lap</span><span class="o">.</span><span class="n">get_weather_data</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">wd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="Laps.pick_driver"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_driver">[docs]</a>    <span class="k">def</span> <span class="nf">pick_driver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps of a specific driver in self based on the driver&#39;s</span>
<span class="sd">        three letters identifier or based on the driver number ::</span>

<span class="sd">            perez_laps = ff1.pick_driver(&#39;PER&#39;)</span>
<span class="sd">            bottas_laps = ff1.pick_driver(77)</span>
<span class="sd">            kimi_laps = ff1.pick_driver(&#39;RAI&#39;)</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier (str or int): Driver abbreviation or number</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">identifier</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_drivers"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_drivers">[docs]</a>    <span class="k">def</span> <span class="nf">pick_drivers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifiers</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps of the specified drivers in self based on the</span>
<span class="sd">        drivers&#39; three letters identifier or based on the driver number. This</span>
<span class="sd">        is the same as :meth:`Laps.pick_driver` but for multiple drivers</span>
<span class="sd">        at once. ::</span>

<span class="sd">            some_drivers_laps = ff1.pick_drivers([5, &#39;BOT&#39;, 7])</span>

<span class="sd">        Args:</span>
<span class="sd">            identifiers (iterable): Multiple driver abbreviations or driver numbers (can be mixed)</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">identifiers</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">identifiers</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
        <span class="n">drv</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Driver&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[(</span><span class="n">drv</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">|</span> <span class="n">num</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">numbers</span><span class="p">))]</span></div>

<div class="viewcode-block" id="Laps.pick_team"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_team">[docs]</a>    <span class="k">def</span> <span class="nf">pick_team</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps of a specific team in self based on the</span>
<span class="sd">        team&#39;s name ::</span>

<span class="sd">            mercedes = ff1.pick_team(&#39;Mercedes&#39;)</span>
<span class="sd">            alfa_romeo = ff1.pick_team(&#39;Alfa Romeo&#39;)</span>

<span class="sd">        Have a look to :attr:`fastf1.plotting.TEAM_COLORS` for a quick reference on team names.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Team name</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_teams"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_teams">[docs]</a>    <span class="k">def</span> <span class="nf">pick_teams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps of the specified teams in self based on the teams&#39;</span>
<span class="sd">        name. This is the same as :meth:`Laps.pick_team` but for multiple</span>
<span class="sd">        teams at once. ::</span>

<span class="sd">            some_drivers_laps = ff1.pick_teams([&#39;Mercedes&#39;, &#39;Williams&#39;])</span>

<span class="sd">        Args:</span>
<span class="sd">            names (iterable): Multiple team names</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Team&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">names</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Laps.pick_fastest"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_fastest">[docs]</a>    <span class="k">def</span> <span class="nf">pick_fastest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_by_time</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Lap&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the lap with the fastest lap time.</span>

<span class="sd">        This method will by default return the quickest lap out of self, that</span>
<span class="sd">        is also marked as personal best lap of a driver.</span>

<span class="sd">        If the quickest lap by lap time is not marked as personal best, this</span>
<span class="sd">        means that it was not counted. This can be the case for example, if</span>
<span class="sd">        the driver exceeded track limits and the lap time was deleted.</span>

<span class="sd">        If no lap is marked as personal best lap or self contains no laps,</span>
<span class="sd">        an empty Lap object will be returned.</span>

<span class="sd">        The check for personal best lap can be disabled, so that any quickest</span>
<span class="sd">        lap will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            only_by_time (bool): Ignore whether any laps are marked as</span>
<span class="sd">                personal best laps and simply return the lap that has the</span>
<span class="sd">                lowest lap time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Lap`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">only_by_time</span><span class="p">:</span>
            <span class="n">laps</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># all laps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># select only laps marked as personal fastest</span>
            <span class="n">laps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;IsPersonalBest&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>  <span class="c1"># noqa: E712 comparison with True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">laps</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Lap</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">lap</span> <span class="o">=</span> <span class="n">laps</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">laps</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lap</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># More laps, same time</span>
            <span class="n">lap</span> <span class="o">=</span> <span class="n">lap</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># take first clocked</span>

        <span class="k">return</span> <span class="n">lap</span></div>

<div class="viewcode-block" id="Laps.pick_quicklaps"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_quicklaps">[docs]</a>    <span class="k">def</span> <span class="nf">pick_quicklaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps with `LapTime` faster than a certain limit. By</span>
<span class="sd">        default the threshold is 107% of the best `LapTime` of all laps</span>
<span class="sd">        in self.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (optional, float): custom threshold coefficent</span>
<span class="sd">                (e.g. 1.05 for 105%)</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Laps</span><span class="o">.</span><span class="n">QUICKLAP_THRESHOLD</span>
        <span class="n">time_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">threshold</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapTime&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time_threshold</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_tyre"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_tyre">[docs]</a>    <span class="k">def</span> <span class="nf">pick_tyre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compound</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps in self which were done on a specific compound.</span>

<span class="sd">        Args:</span>
<span class="sd">            compound (string): may be &quot;SOFT&quot;, &quot;MEDIUM&quot;, &quot;HARD&quot;, &quot;INTERMEDIATE&quot; or &quot;WET&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Compound&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">compound</span><span class="p">]</span></div>

<div class="viewcode-block" id="Laps.pick_track_status"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_track_status">[docs]</a>    <span class="k">def</span> <span class="nf">pick_track_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;equals&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps set under a specific track status.</span>

<span class="sd">        Args:</span>
<span class="sd">            status (str): The track status as a string, e.g. &#39;1&#39;</span>
<span class="sd">            how (str): one of &#39;equals&#39;/&#39;contains&#39;</span>
<span class="sd">                For example, if how=&#39;equals&#39;, status=&#39;2&#39; will only match &#39;2&#39;.</span>
<span class="sd">                If how=&#39;contains&#39;, status=&#39;2&#39; will also match &#39;267&#39; and similar</span>
<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;equals&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">status</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;contains&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;TrackStatus&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value &#39;</span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&#39; for kwarg &#39;how&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Laps.pick_wo_box"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_wo_box">[docs]</a>    <span class="k">def</span> <span class="nf">pick_wo_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps which are NOT in laps or out laps.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PitInTime&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;PitOutTime&#39;</span><span class="p">])]</span></div>

<div class="viewcode-block" id="Laps.pick_accurate"><a class="viewcode-back" href="../../core.html#fastf1.Laps.pick_accurate">[docs]</a>    <span class="k">def</span> <span class="nf">pick_accurate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Laps&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return all laps which pass the accuracy validation check</span>
<span class="sd">        (lap[&#39;IsAccurate&#39;] is True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Laps`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;IsAccurate&#39;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="Laps.iterlaps"><a class="viewcode-back" href="../../core.html#fastf1.Laps.iterlaps">[docs]</a>    <span class="k">def</span> <span class="nf">iterlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">require</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Lap&quot;</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Iterator for iterating over all laps in self.</span>

<span class="sd">        This method wraps :meth:`pandas.DataFrame.iterrows`.</span>
<span class="sd">        It additionally provides the `require` keyword argument.</span>

<span class="sd">        Args:</span>
<span class="sd">             require (optional, iterable): Require is a list of column/telemetry channel names. All names listed in</span>
<span class="sd">               `require` must exist in the data and have a non-null value (tested with :func:`pandas.is_null`). The</span>
<span class="sd">               iterator only yields laps for which this is true. If require is left empty, the iterator will yield</span>
<span class="sd">               all laps.</span>
<span class="sd">        Yields:</span>
<span class="sd">            (index, instance of :class:`Lap`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">lap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">require</span><span class="p">:</span>
                <span class="c1"># make sure that all required values even exist in the index</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lap</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">require</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">require</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">require</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lap</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">lap</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">require</span><span class="p">]):</span>
                    <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">index</span><span class="p">,</span> <span class="n">lap</span></div></div>


<div class="viewcode-block" id="Lap"><a class="viewcode-back" href="../../core.html#fastf1.Lap">[docs]</a><span class="k">class</span> <span class="nc">Lap</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object for accessing lap (timing) data of a single lap.</span>

<span class="sd">    This class wraps :class:`pandas.Series`. It provides extra functionality for accessing a lap&#39;s associated</span>
<span class="sd">    telemetry data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;session&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Lap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for this lap</span>

<span class="sd">        This is a cached (!) property for :meth:`get_telemetry`. It will return the same value as `get_telemetry`</span>
<span class="sd">        but cache the result so that the involved processing is only done once.</span>

<span class="sd">        This is mainly provided for convenience and backwards compatibility.</span>

<span class="sd">        See :meth:`get_telemetry` for more information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_telemetry</span><span class="p">()</span>

<div class="viewcode-block" id="Lap.get_telemetry"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_telemetry">[docs]</a>    <span class="k">def</span> <span class="nf">get_telemetry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Telemetry data for this lap</span>

<span class="sd">        Telemetry data is the result of merging the returned data from :meth:`get_car_data` and :meth:`get_pos_data`.</span>
<span class="sd">        This means that telemetry data at least partially contains interpolated values! Telemetry data additionally</span>
<span class="sd">        already has computed channels added (e.g. Distance).</span>

<span class="sd">        This method is provided for convenience and compatibility reasons. But using it does usually not produce</span>
<span class="sd">        the most accurate possible result.</span>
<span class="sd">        It is recommended to use :meth:`get_car_data` or :meth:`get_pos_data` when possible. This is also faster if</span>
<span class="sd">        merging of car and position data is not necessary and if not all computed channels are needed.</span>

<span class="sd">        Resampling during merging is done according to the frequency set by :attr:`TELEMETRY_FREQUENCY`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_car_data</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pad_side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>

        <span class="c1"># calculate driver ahead from from data without padding to</span>
        <span class="c1"># prevent out of bounds errors</span>
        <span class="n">drv_ahead</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> \
            <span class="o">.</span><span class="n">add_driver_ahead</span><span class="p">()</span> \
            <span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;DriverAhead&#39;</span><span class="p">,</span> <span class="s1">&#39;DistanceToDriverAhead&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;SessionTime&#39;</span><span class="p">)]</span>

        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">add_distance</span><span class="p">()</span><span class="o">.</span><span class="n">add_relative_distance</span><span class="p">()</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="n">car_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">drv_ahead</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">pos_data</span><span class="o">.</span><span class="n">merge_channels</span><span class="p">(</span><span class="n">car_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolate_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lap.get_car_data"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_car_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_car_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Car data for this lap</span>

<span class="sd">        Slices the car data in :attr:`Session.car_data` using this lap and returns the result.</span>

<span class="sd">        The data returned by this method does not contain computed telemetry channels. The can be added by calling the</span>
<span class="sd">        appropriate `add_*()` method on the returned telemetry object.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">car_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">car_data</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">car_data</span></div>

<div class="viewcode-block" id="Lap.get_pos_data"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_pos_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Telemetry</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pos data for all laps in `self`</span>

<span class="sd">        Slices the position data in :attr:`Session.pos_data` using this lap and returns the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs: Keyword arguments are passed to :meth:`Telemetry.slice_by_lap`</span>

<span class="sd">        Returns:</span>
<span class="sd">            instance of :class:`Telemetry`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">pos_data</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;DriverNumber&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">slice_by_lap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos_data</span></div>

<div class="viewcode-block" id="Lap.get_weather_data"><a class="viewcode-back" href="../../core.html#fastf1.Lap.get_weather_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_weather_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return weather data for this lap.</span>

<span class="sd">        Weather data is updated once per minute. This means that there are</span>
<span class="sd">        usually one or two data points per lap. This function will always</span>
<span class="sd">        return only one data point:</span>

<span class="sd">            - The first value within the duration of a lap</span>

<span class="sd">        or</span>

<span class="sd">            - the last known value before the end of the lap if there are</span>
<span class="sd">              no values within the duration of a lap</span>

<span class="sd">        See :func:`fastf1.api.weather_data` for available data</span>
<span class="sd">        channels.</span>

<span class="sd">        If you wish to have more control over the data, you can access the</span>
<span class="sd">        weather data directly in :attr:`Session.weather_data`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pandas.Series</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; session = fastf1.get_session(2019, &#39;Monza&#39;, &#39;Q&#39;)</span>
<span class="sd">            &gt;&gt;&gt; session.load(telemetry=False)</span>
<span class="sd">            &gt;&gt;&gt; lap = session.laps.pick_fastest()</span>
<span class="sd">            &gt;&gt;&gt; lap[&#39;LapStartTime&#39;]</span>
<span class="sd">            Timedelta(&#39;0 days 01:09:55.561000&#39;)</span>
<span class="sd">            &gt;&gt;&gt; lap.get_weather_data()</span>
<span class="sd">            Time             0 days 01:10:15.292000</span>
<span class="sd">            AirTemp                            23.0</span>
<span class="sd">            Humidity                           51.9</span>
<span class="sd">            Pressure                          992.4</span>
<span class="sd">            Rainfall                          False</span>
<span class="sd">            TrackTemp                          37.8</span>
<span class="sd">            WindDirection                       166</span>
<span class="sd">            WindSpeed                           0.8</span>
<span class="sd">            Name: 70, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get first value within the duration of the lap</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LapStartTime&#39;</span><span class="p">])</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]))</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">samples</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samples</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># fallback: get last value before the lap ended</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Time&#39;</span><span class="p">]</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">samples</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samples</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># no data: return an empty Series with the correct index names</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">weather_data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SessionResults"><a class="viewcode-back" href="../../core.html#fastf1.SessionResults">[docs]</a><span class="k">class</span> <span class="nc">SessionResults</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides driver and result information for all drivers that</span>
<span class="sd">    participated in a session.</span>

<span class="sd">    This class subclasses a :class:`pandas.DataFrame` and the usual methods</span>
<span class="sd">    provided by pandas can be used to work with the data.</span>

<span class="sd">    **All dataframe columns will always exist even if they are not relevant</span>
<span class="sd">    for the current session!**</span>

<span class="sd">    The following information is provided for each driver as a column of the</span>
<span class="sd">    dataframe:</span>

<span class="sd">        - ``DriverNumber`` | :class:`str` |</span>
<span class="sd">          The number associated with this driver in this session (usually the</span>
<span class="sd">          drivers permanent number)</span>

<span class="sd">        - ``BroadcastName`` | :class:`str` |</span>
<span class="sd">          First letter of the drivers first name plus the drivers full last name</span>
<span class="sd">          in all capital letters. (e.g. &#39;P GASLY&#39;)</span>

<span class="sd">        - ``FullName`` | :class:`str` |</span>
<span class="sd">          The drivers full name (e.g. &quot;Pierre Gasly&quot;)</span>

<span class="sd">        - ``Abbreviation`` | :class:`str` |</span>
<span class="sd">          The drivers three letter abbreviation (e.g. &quot;GAS&quot;)</span>

<span class="sd">        - ``TeamName`` | :class:`str` |</span>
<span class="sd">          The team name (short version without title sponsors)</span>

<span class="sd">        - ``TeamColor`` | :class:`str` |</span>
<span class="sd">          The color commonly associated with this team (hex value)</span>

<span class="sd">        - ``FirstName`` | :class:`str` |</span>
<span class="sd">          The drivers first name</span>

<span class="sd">        - ``LastName`` | :class:`str` |</span>
<span class="sd">          The drivers last name</span>

<span class="sd">        - ``Position`` | :class:`float` |</span>
<span class="sd">          The drivers finishing position (values only given if session is</span>
<span class="sd">          &#39;Race&#39;, &#39;Qualifying&#39; or &#39;Sprint Qualifying&#39;)</span>

<span class="sd">        - ``GridPosition`` | :class:`float` |</span>
<span class="sd">          The drivers starting position (values only given if session is</span>
<span class="sd">          &#39;Race&#39; or &#39;Sprint Qualifying&#39;)</span>

<span class="sd">        - ``Q1`` | :class:`pd.Timedelta` |</span>
<span class="sd">          The drivers best Q1 time (values only given if session is</span>
<span class="sd">          &#39;Qualifying&#39;)</span>

<span class="sd">        - ``Q2`` | :class:`pd.Timedelta` |</span>
<span class="sd">          The drivers best Q2 time (values only given if session is</span>
<span class="sd">          &#39;Qualifying&#39;)</span>

<span class="sd">        - ``Q3`` | :class:`pd.Timedelta` |</span>
<span class="sd">          The drivers best Q3 time (values only given if session is</span>
<span class="sd">          &#39;Qualifying&#39;)</span>

<span class="sd">        - ``Time`` | :class:`pd.Timedelta` |</span>
<span class="sd">          The drivers total race time (values only given if session is</span>
<span class="sd">          &#39;Race&#39; or &#39;Sprint Qualifying&#39; and the driver was not more than one</span>
<span class="sd">          lap behind the leader)</span>

<span class="sd">        - ``Status`` | :class:`str` |</span>
<span class="sd">          A status message to indicate if and how the driver finished the race</span>
<span class="sd">          or to indicate the cause of a DNF. Possible values include but are</span>
<span class="sd">          not limited to &#39;Finished&#39;, &#39;+ 1 Lap&#39;, &#39;Crash&#39;, &#39;Gearbox&#39;, ...</span>
<span class="sd">          (values only given if session is &#39;Race&#39; or &#39;Sprint Qualifying&#39;)</span>

<span class="sd">        - ``Status`` | :class:`float` |</span>
<span class="sd">          The number of points received by each driver for their finishing</span>
<span class="sd">          result.</span>

<span class="sd">    By default, the session results are indexed by driver number and sorted by</span>
<span class="sd">    finishing position.</span>

<span class="sd">    .. note:: This class is usually not instantiated directly. You should</span>
<span class="sd">        create a session and access the session result through the</span>
<span class="sd">        :attr:`Session.results` property.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args: passed on to :class:`pandas.DataFrame` superclass</span>
<span class="sd">        force_default_cols (bool): Enforce that all default columns and only</span>
<span class="sd">            the default columns exist</span>
<span class="sd">        **kwargs: passed on to :class:`pandas.DataFrame` superclass</span>
<span class="sd">            (except &#39;columns&#39; which is unsupported for this object)</span>

<span class="sd">    .. versionadded:: 2.2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_COL_TYPES</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;DriverNumber&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;BroadcastName&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;Abbreviation&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;TeamName&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;TeamColor&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;FirstName&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;LastName&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;FullName&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;Position&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;GridPosition&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="s1">&#39;Q1&#39;</span><span class="p">:</span> <span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q2&#39;</span><span class="p">:</span> <span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q3&#39;</span><span class="p">:</span> <span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Time&#39;</span><span class="p">:</span> <span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Status&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="s1">&#39;Points&#39;</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">}</span>

    <span class="n">_internal_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;base_class_view&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">force_default_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">force_default_cols</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;columns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_COL_TYPES</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># apply column specific dtypes</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COL_TYPES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">_type</span><span class="p">()</span>

            <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_class_view</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SessionResults</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DriverResult</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_class_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For a nicer debugging experience; can view DataFrame through</span>
<span class="sd">        this property in various IDEs&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="DriverResult"><a class="viewcode-back" href="../../core.html#fastf1.DriverResult">[docs]</a><span class="k">class</span> <span class="nc">DriverResult</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides driver and result information for a single driver.</span>

<span class="sd">    This class subclasses a :class:`pandas.Series` and the usual methods</span>
<span class="sd">    provided by pandas can be used to work with the data.</span>

<span class="sd">    For information on which data is available, see :class:`SessionResult`.</span>

<span class="sd">    .. note:: This class is usually not instantiated directly. You should</span>
<span class="sd">        create a session and access the driver result through</span>
<span class="sd">        :func:`Session.get_driver` or by slicing the session result.</span>

<span class="sd">    Args:</span>
<span class="sd">        *args: passed on to :class:`pandas.Series` superclass</span>
<span class="sd">        **kwargs: passed on to :class:`pandas.Series` superclass</span>

<span class="sd">    .. versionadded:: 2.2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getattr_override</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># TODO: remove in v2.3</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DriverResult</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_new</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_getattr_override&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;FirstName&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The `Driver.name` property is deprecated and will be&quot;</span>
                    <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Use `Driver[&#39;FirstName&#39;]` or `Driver.FirstName` instead.&quot;</span><span class="p">,</span>
                    <span class="ne">FutureWarning</span>
                <span class="p">)</span>
                <span class="c1"># name may be accessed by pandas internals to, when data</span>
                <span class="c1"># does not exist yet</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;FirstName&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># don&#39;t show .name deprecation message when .name is accessed internally</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                                    <span class="n">message</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;.*property is deprecated.*&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dnf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;True if driver did not finish&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Status</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Lap&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Status</span> <span class="o">==</span> <span class="s1">&#39;Finished&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid position</span>

<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            Use ``Driver[&#39;GridPosition&#39;]`` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The `Driver.grid` property is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Driver[&#39;GridPosition&#39;]` or `Driver.GridPosition` &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;GridPosition&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finishing position</span>

<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            Use ``Driver[&#39;Position&#39;]`` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The `Driver.position` property is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Driver[&#39;Position&#39;]` or `Driver.Position` &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;Position&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">familyname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Driver family name</span>

<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            Use ``Driver[&#39;LastName&#39;]`` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The `Driver.position` property is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Driver[&#39;LastName&#39;]` or `Driver.LastName` &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;LastName&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">team</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Team name</span>

<span class="sd">        .. deprecated:: 2.2</span>
<span class="sd">            Use ``Driver[&#39;TeamName&#39;]`` instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: remove in v2.3</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The `Driver.team` property is deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `Driver[&#39;TeamName&#39;]` or `Driver.TeamName` &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;TeamName&#39;</span><span class="p">]</span></div>


<span class="k">class</span> <span class="nc">Driver</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. deprecated:: 2.2</span>
<span class="sd">        Use :class:`fastf1.core.DriverResult` instead</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`fastf1.core.Driver` has been deprecated and will be&quot;</span>
                      <span class="s2">&quot;removed in a future version.</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="s2">&quot;Use `fastf1.core.DriverResult` instead.&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DriverResult</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">DataNotLoadedError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if an attempt is made to access data that has not been loaded</span>
<span class="sd">    yet.&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="NoLapDataError"><a class="viewcode-back" href="../../core.html#fastf1.NoLapDataError">[docs]</a><span class="k">class</span> <span class="nc">NoLapDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if the API request does not fail but there is no usable data after processing the result.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NoLapDataError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;Failed to load session because the API did not provide any usable data.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="InvalidSessionError"><a class="viewcode-back" href="../../core.html#fastf1.InvalidSessionError">[docs]</a><span class="k">class</span> <span class="nc">InvalidSessionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised if no session for the specified event name, type and year</span>
<span class="sd">    can be found.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InvalidSessionError</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="s2">&quot;No matching session can be found.&quot;</span>
        <span class="p">)</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, theOehrly
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>